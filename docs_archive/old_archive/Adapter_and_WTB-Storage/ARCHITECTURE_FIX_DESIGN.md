# WTB æ¶æ„ä¿®å¤è®¾è®¡æ–‡æ¡£

## Executive Summary

æœ¬æ–‡æ¡£é’ˆå¯¹æ¶æ„å®¡æŸ¥ä¸­å‘ç°çš„å…³é”®é—®é¢˜ï¼Œæä¾› P0-P1 ä¼˜å…ˆçº§çš„è®¾è®¡ä¿®å¤æ–¹æ¡ˆã€‚

| ä¼˜å…ˆçº§ | é—®é¢˜ | è§£å†³æ–¹æ¡ˆ | çŠ¶æ€ |
|--------|------|----------|------|
| **P0** | è·¨åº“äº‹åŠ¡ä¸€è‡´æ€§ | Outbox Pattern | æœ¬æ–‡æ¡£è®¾è®¡ |
| **P0** | æ•°æ®å®Œæ•´æ€§ | IntegrityChecker | æœ¬æ–‡æ¡£è®¾è®¡ |
| **P1** | é¢†åŸŸæ¨¡å‹è´«è¡€ | Rich Domain Model | æœ¬æ–‡æ¡£è®¾è®¡ |
| P2 | é”™è¯¯æ ‡å‡†åŒ– | Error Hierarchy | åç»­æ–‡æ¡£ |

### ä¸‰åº“æ¶æ„æ€»è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           WTB ä¸‰æ•°æ®åº“æ¶æ„ (ä¿®å¤å)                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                          åº”ç”¨å±‚ (Application Layer)                          â”‚   â”‚
â”‚   â”‚                                                                              â”‚   â”‚
â”‚   â”‚     ExecutionController â”€â”€â–º NodeReplacer â”€â”€â–º BatchTestRunner                â”‚   â”‚
â”‚   â”‚              â”‚                                                               â”‚   â”‚
â”‚   â”‚              â–¼                                                               â”‚   â”‚
â”‚   â”‚     AgentGitStateAdapter (Anti-Corruption Layer)                            â”‚   â”‚
â”‚   â”‚                                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                      â”‚                                               â”‚
â”‚                                      â”‚ åè°ƒä¸‰ä¸ªæ•°æ®åº“                                â”‚
â”‚                                      â”‚                                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                         WTB Database (SQLite/PostgreSQL)                     â”‚   â”‚
â”‚   â”‚                              â•â•â•â•â• äº‹åŠ¡ä¸­å¿ƒ â•â•â•â•â•                             â”‚   â”‚
â”‚   â”‚                                                                              â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚   â”‚  â”‚ wtb_executions â”‚  â”‚ node_boundariesâ”‚  â”‚checkpoint_filesâ”‚  â”‚  outbox    â”‚ â”‚   â”‚
â”‚   â”‚  â”‚                â”‚  â”‚                â”‚  â”‚                â”‚  â”‚            â”‚ â”‚   â”‚
â”‚   â”‚  â”‚ æ‰§è¡Œè®°å½•        â”‚  â”‚ èŠ‚ç‚¹è¾¹ç•ŒæŒ‡é’ˆ    â”‚  â”‚ æ–‡ä»¶é“¾æ¥        â”‚  â”‚ å¾…å¤„ç†äº‹ä»¶ â”‚ â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚   â”‚          â”‚                   â”‚                   â”‚                 â”‚        â”‚   â”‚
â”‚   â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚   â”‚
â”‚   â”‚                              â”‚                                               â”‚   â”‚
â”‚   â”‚                         åŒä¸€äº‹åŠ¡å†™å…¥                                          â”‚   â”‚
â”‚   â”‚                                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                      â”‚                                               â”‚
â”‚                              Outbox Processor (åå°)                                â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚
â”‚                      â”‚               â”‚               â”‚                              â”‚
â”‚                      â–¼               â–¼               â–¼                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚   â”‚  AgentGit Database   â”‚ â”‚ FileTracker Database â”‚ â”‚ FileTracker Storage  â”‚        â”‚
â”‚   â”‚  (SQLite)            â”‚ â”‚ (PostgreSQL)         â”‚ â”‚ (File System)        â”‚        â”‚
â”‚   â”‚                      â”‚ â”‚                      â”‚ â”‚                      â”‚        â”‚
â”‚   â”‚ â€¢ checkpoints        â”‚ â”‚ â€¢ commits            â”‚ â”‚ â€¢ objects/{hash[:2]} â”‚        â”‚
â”‚   â”‚ â€¢ internal_sessions  â”‚ â”‚ â€¢ file_blobs         â”‚ â”‚   /{hash[2:]}        â”‚        â”‚
â”‚   â”‚ â€¢ external_sessions  â”‚ â”‚ â€¢ file_mementos      â”‚ â”‚                      â”‚        â”‚
â”‚   â”‚ â€¢ users              â”‚ â”‚                      â”‚ â”‚                      â”‚        â”‚
â”‚   â”‚                      â”‚ â”‚                      â”‚ â”‚                      â”‚        â”‚
â”‚   â”‚ èŒè´£: çŠ¶æ€å¿«ç…§ + å›æ»š â”‚ â”‚ èŒè´£: æ–‡ä»¶å…ƒæ•°æ®     â”‚ â”‚ èŒè´£: æ–‡ä»¶å†…å®¹å­˜å‚¨   â”‚        â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                                                      â”‚
â”‚   ä¸€è‡´æ€§ä¿è¯:                                                                        â”‚
â”‚   â•â•â•â•â•â•â•â•â•â•â•                                                                        â”‚
â”‚   â€¢ WTB æ˜¯"äº‹åŠ¡ä¸­å¿ƒ" - æ‰€æœ‰ä¸šåŠ¡æ•°æ® + Outbox åŸå­å†™å…¥                                â”‚
â”‚   â€¢ Outbox Processor å¼‚æ­¥éªŒè¯ AgentGit + FileTracker æ•°æ®                           â”‚
â”‚   â€¢ IntegrityChecker å®šæœŸæ£€æŸ¥ä¸‰åº“å¼•ç”¨å®Œæ•´æ€§                                          â”‚
â”‚   â€¢ æœ€ç»ˆä¸€è‡´æ€§ + è¡¥å¿æœºåˆ¶                                                            â”‚
â”‚                                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. Outbox Pattern è¯¦è§£

### 1.1 é—®é¢˜èƒŒæ™¯

åœ¨ WTB ç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬é¢ä¸´**ä¸‰åº“è·¨æ•°æ®åº“ä¸€è‡´æ€§**é—®é¢˜ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         WTB ä¸‰æ•°æ®åº“æ¶æ„                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚   â”‚   WTB Database      â”‚  â”‚   AgentGit Database â”‚  â”‚ FileTracker Databaseâ”‚     â”‚
â”‚   â”‚   (SQLite/PG)       â”‚  â”‚   (SQLite)          â”‚  â”‚ (PostgreSQL)        â”‚     â”‚
â”‚   â”‚                     â”‚  â”‚                     â”‚  â”‚                     â”‚     â”‚
â”‚   â”‚ â€¢ wtb_workflows     â”‚  â”‚ â€¢ checkpoints       â”‚  â”‚ â€¢ commits           â”‚     â”‚
â”‚   â”‚ â€¢ wtb_executions    â”‚  â”‚ â€¢ internal_sessions â”‚  â”‚ â€¢ file_blobs        â”‚     â”‚
â”‚   â”‚ â€¢ wtb_node_bounds   â”‚â”€â”€â”‚ â€¢ external_sessions â”‚â”€â”€â”‚ â€¢ file_mementos     â”‚     â”‚
â”‚   â”‚ â€¢ wtb_checkpoint_   â”‚  â”‚ â€¢ users             â”‚  â”‚                     â”‚     â”‚
â”‚   â”‚     files           â”‚  â”‚                     â”‚  â”‚ + æ–‡ä»¶ç³»ç»Ÿ:         â”‚     â”‚
â”‚   â”‚                     â”‚  â”‚                     â”‚  â”‚   objects/{hash}    â”‚     â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚            â”‚                        â”‚                        â”‚                   â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ é€»è¾‘å¤–é”® â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€ é€»è¾‘å¤–é”® â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                                                  â”‚
â”‚   è·¨åº“å¼•ç”¨é“¾:                                                                    â”‚
â”‚   wtb_node_boundaries.entry_checkpoint_id â†’ agentgit.checkpoints.id             â”‚
â”‚   wtb_checkpoint_files.checkpoint_id â†’ agentgit.checkpoints.id                  â”‚
â”‚   wtb_checkpoint_files.file_commit_id â†’ filetracker.commits.commit_id           â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å½“å‰é—®é¢˜ï¼šä¸‰é˜¶æ®µéåŸå­æ“ä½œ                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚   ExecutionController.run()                                                      â”‚
â”‚        â”‚                                                                         â”‚
â”‚        â”œâ”€â‘  save_checkpoint() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º AgentGit DB (SQLite)           â”‚
â”‚        â”‚     â””â”€â”€ self._checkpoint_repo.create()  âœ… ç‹¬ç«‹ Commit                  â”‚
â”‚        â”‚                                                                         â”‚
â”‚        â”œâ”€â‘¡ mark_node_started() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º WTB DB (SQLite/PostgreSQL)     â”‚
â”‚        â”‚     â””â”€â”€ uow.node_boundaries.add()       âœ… ç‹¬ç«‹ Commit                  â”‚
â”‚        â”‚                                                                         â”‚
â”‚        â”œâ”€â‘¢ track_files() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º FileTracker DB (PostgreSQL)    â”‚
â”‚        â”‚     â””â”€â”€ commit_repo.save(commit)        âœ… ç‹¬ç«‹ Commit                  â”‚
â”‚        â”‚                                                                         â”‚
â”‚        â”œâ”€â‘£ link_file_commit() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º WTB DB                          â”‚
â”‚        â”‚     â””â”€â”€ uow.checkpoint_files.add()      âœ… ç‹¬ç«‹ Commit                  â”‚
â”‚        â”‚                                                                         â”‚
â”‚        â”‚   âš ï¸ ä»»æ„æ­¥éª¤å¤±è´¥ â†’ ç³»ç»Ÿä¸ä¸€è‡´ï¼                                        â”‚
â”‚        â”‚   â€¢ åœºæ™¯A: â‘  æˆåŠŸï¼Œâ‘¡â‘¢â‘£ å¤±è´¥ â†’ å­¤å„¿ checkpoint                          â”‚
â”‚        â”‚   â€¢ åœºæ™¯B: â‘ â‘¡â‘¢ æˆåŠŸï¼Œâ‘£ å¤±è´¥ â†’ checkpoint å’Œ file_commit æœªå…³è”          â”‚
â”‚        â”‚   â€¢ åœºæ™¯C: â‘ â‘¡ æˆåŠŸï¼Œâ‘¢ å¤±è´¥ â†’ çŠ¶æ€å·²ä¿å­˜ï¼Œä½†æ–‡ä»¶æœªè¿½è¸ª                    â”‚
â”‚        â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ä»€ä¹ˆæ˜¯ Outbox Pattern?

**Outbox Pattern**ï¼ˆå‘ä»¶ç®±æ¨¡å¼ï¼‰æ˜¯è§£å†³**åˆ†å¸ƒå¼äº‹åŠ¡**é—®é¢˜çš„ç»å…¸æ¨¡å¼ï¼Œæºè‡ªå¾®æœåŠ¡æ¶æ„ï¼Œä½†åŒæ ·é€‚ç”¨äºå¤šæ•°æ®åº“åœºæ™¯ã€‚

#### æ ¸å¿ƒæ€æƒ³

> **"å°†è·¨ç³»ç»Ÿæ“ä½œè½¬æ¢ä¸ºæœ¬åœ°äº‹åŠ¡ + å¯é æ¶ˆæ¯ä¼ é€’"**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Outbox Pattern åŸç†å›¾                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚   ä¼ ç»Ÿæ–¹å¼ï¼ˆæœ‰é£é™©ï¼‰:                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚
â”‚   â”‚   Database A    â”‚      â”‚   Database B    â”‚                                  â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚      â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚                                  â”‚
â”‚   â”‚   â”‚ Table 1 â”‚â—„â”€â”€â”¼â”€â”€â‘ â”€â”€â”€â”¼â”€â”€â–ºâ”‚ Table 2 â”‚   â”‚   â‘  ç›´æ¥è·¨åº“å†™å…¥                 â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚      â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   âš ï¸ æ— æ³•ä¿è¯åŸå­æ€§              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  â”‚
â”‚                                                                                  â”‚
â”‚   Outbox Patternï¼ˆå¯é ï¼‰:                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚
â”‚   â”‚   Database A    â”‚      â”‚   Database B    â”‚                                  â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚      â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚                                  â”‚
â”‚   â”‚   â”‚ Table 1 â”‚   â”‚      â”‚   â”‚ Table 2 â”‚   â”‚                                  â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â”‚      â”‚   â””â”€â”€â”€â”€â–²â”€â”€â”€â”€â”˜   â”‚                                  â”‚
â”‚   â”‚        â”‚        â”‚      â”‚        â”‚        â”‚                                  â”‚
â”‚   â”‚   â‘  åŒä¸€äº‹åŠ¡     â”‚      â”‚   â‘¢ Workerå†™å…¥ â”‚                                  â”‚
â”‚   â”‚        â”‚        â”‚      â”‚        â”‚        â”‚                                  â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”   â”‚      â”‚        â”‚        â”‚                                  â”‚
â”‚   â”‚   â”‚ Outbox  â”‚â”€â”€â”€â”¼â”€â”€â‘¡â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚   â‘  ä¸šåŠ¡æ•°æ®+OutboxåŒä¸€äº‹åŠ¡      â”‚
â”‚   â”‚   â”‚  Table  â”‚   â”‚ è½®è¯¢ â”‚                 â”‚   â‘¡ Workerè½®è¯¢Outbox            â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚      â”‚                 â”‚   â‘¢ å†™å…¥ç›®æ ‡æ•°æ®åº“              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â‘£ æ ‡è®°Outboxå·²å¤„ç†            â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ ¸å¿ƒä¿è¯

1. **At-Least-Once Delivery**ï¼šæ¶ˆæ¯è‡³å°‘æŠ•é€’ä¸€æ¬¡
2. **æœ€ç»ˆä¸€è‡´æ€§**ï¼šç³»ç»Ÿæœ€ç»ˆä¼šè¾¾åˆ°ä¸€è‡´çŠ¶æ€
3. **å¯æ¢å¤æ€§**ï¼šå³ä½¿ Worker å´©æºƒï¼Œé‡å¯åç»§ç»­å¤„ç†

### 1.3 WTB ä¸‰åº“åœºæ™¯ä¸‹çš„ Outbox Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       WTB ä¸‰åº“ Outbox Pattern è®¾è®¡                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚   â”‚                    WTB Database (Primary - äº‹åŠ¡ä¸­å¿ƒ)                       â”‚     â”‚
â”‚   â”‚                                                                            â”‚     â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚     â”‚
â”‚   â”‚  â”‚                    SINGLE TRANSACTION (åŸå­æ€§ä¿è¯)                   â”‚   â”‚     â”‚
â”‚   â”‚  â”‚                                                                     â”‚   â”‚     â”‚
â”‚   â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚     â”‚
â”‚   â”‚  â”‚  â”‚ node_boundaries  â”‚  â”‚ checkpoint_filesâ”‚  â”‚     outbox      â”‚    â”‚   â”‚     â”‚
â”‚   â”‚  â”‚  â”‚                  â”‚  â”‚                 â”‚  â”‚                 â”‚    â”‚   â”‚     â”‚
â”‚   â”‚  â”‚  â”‚ â€¢ node_id        â”‚  â”‚ â€¢ checkpoint_id â”‚  â”‚ â€¢ event_type    â”‚    â”‚   â”‚     â”‚
â”‚   â”‚  â”‚  â”‚ â€¢ entry_cp_id    â”‚  â”‚ â€¢ file_commit_idâ”‚  â”‚ â€¢ payload       â”‚    â”‚   â”‚     â”‚
â”‚   â”‚  â”‚  â”‚ â€¢ exit_cp_id     â”‚  â”‚ â€¢ file_count    â”‚  â”‚ â€¢ status        â”‚    â”‚   â”‚     â”‚
â”‚   â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚     â”‚
â”‚   â”‚  â”‚           â”‚                     â”‚                    â”‚             â”‚   â”‚     â”‚
â”‚   â”‚  â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚   â”‚     â”‚
â”‚   â”‚  â”‚                                 â”‚                                   â”‚   â”‚     â”‚
â”‚   â”‚  â”‚                            â‘  åŒä¸€äº‹åŠ¡å†™å…¥                           â”‚   â”‚     â”‚
â”‚   â”‚  â”‚                                                                     â”‚   â”‚     â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚     â”‚
â”‚   â”‚                                    â”‚                                        â”‚     â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                        â”‚                                              â”‚
â”‚                                   â‘¡ Outbox Processor                                 â”‚
â”‚                                      (Worker)                                        â”‚
â”‚                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚                       â”‚                â”‚                â”‚                            â”‚
â”‚                       â–¼                â–¼                â–¼                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚   AgentGit Database   â”‚  â”‚  FileTracker Database â”‚  â”‚  FileTracker Storage  â”‚   â”‚
â”‚   â”‚   (SQLite)            â”‚  â”‚  (PostgreSQL)         â”‚  â”‚  (File System)        â”‚   â”‚
â”‚   â”‚                       â”‚  â”‚                       â”‚  â”‚                       â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚   â”‚  â”‚   checkpoints    â”‚  â”‚  â”‚  â”‚     commits     â”‚  â”‚  â”‚  â”‚  objects/{hash} â”‚  â”‚   â”‚
â”‚   â”‚  â”‚   â‘¢ éªŒè¯å­˜åœ¨     â”‚  â”‚  â”‚  â”‚   â‘£ éªŒè¯å­˜åœ¨    â”‚  â”‚  â”‚  â”‚   â‘¤ éªŒè¯æ–‡ä»¶    â”‚  â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚                       â”‚   â”‚
â”‚   â”‚  â”‚ internal_sessionsâ”‚  â”‚  â”‚  â”‚   file_blobs    â”‚  â”‚  â”‚                       â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚   file_mementos â”‚  â”‚  â”‚                       â”‚   â”‚
â”‚   â”‚                       â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚                       â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                                      â”‚
â”‚   æµç¨‹è¯´æ˜:                                                                          â”‚
â”‚   â‘  WTB ä¸šåŠ¡æ•°æ® + Outbox äº‹ä»¶ åœ¨åŒä¸€äº‹åŠ¡ä¸­å†™å…¥ WTB DB (åŸå­æ€§ä¿è¯)                  â”‚
â”‚   â‘¡ Outbox Processor (åå° Worker) è½®è¯¢ pending äº‹ä»¶                                â”‚
â”‚   â‘¢ éªŒè¯ AgentGit checkpoint å­˜åœ¨ä¸”æ•°æ®æ­£ç¡®                                         â”‚
â”‚   â‘£ éªŒè¯ FileTracker commit å­˜åœ¨ (å¦‚æœæ¶‰åŠæ–‡ä»¶æ“ä½œ)                                 â”‚
â”‚   â‘¤ éªŒè¯å®é™…æ–‡ä»¶åœ¨ objects/ ç›®å½•ä¸­å­˜åœ¨                                              â”‚
â”‚   â‘¥ å…¨éƒ¨éªŒè¯é€šè¿‡åï¼Œæ ‡è®° Outbox äº‹ä»¶ä¸º "processed"                                   â”‚
â”‚                                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.4 FileTracker é›†æˆè®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FileTracker åœ¨ Outbox Pattern ä¸­çš„è§’è‰²                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                      â”‚
â”‚   åœºæ™¯ï¼šèŠ‚ç‚¹æ‰§è¡Œäº§ç”Ÿæ–‡ä»¶å˜æ›´ï¼ˆå¦‚ train èŠ‚ç‚¹ç”Ÿæˆ model.pklï¼‰                           â”‚
â”‚                                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                          èŠ‚ç‚¹æ‰§è¡Œæµç¨‹                                         â”‚   â”‚
â”‚   â”‚                                                                              â”‚   â”‚
â”‚   â”‚   NodeExecutor.execute("train")                                              â”‚   â”‚
â”‚   â”‚        â”‚                                                                     â”‚   â”‚
â”‚   â”‚        â”œâ”€â‘  æ‰§è¡Œè®­ç»ƒé€»è¾‘ï¼Œç”Ÿæˆ model.pkl                                      â”‚   â”‚
â”‚   â”‚        â”‚                                                                     â”‚   â”‚
â”‚   â”‚        â”œâ”€â‘¡ FileTracker: ä¿å­˜æ–‡ä»¶å¿«ç…§                                         â”‚   â”‚
â”‚   â”‚        â”‚     â”œâ”€â”€ blob_repo.save_file("model.pkl") â†’ file_hash               â”‚   â”‚
â”‚   â”‚        â”‚     â”œâ”€â”€ commit = Commit(mementos=[FileMemento(...)])               â”‚   â”‚
â”‚   â”‚        â”‚     â””â”€â”€ commit_repo.save(commit) â†’ file_commit_id                  â”‚   â”‚
â”‚   â”‚        â”‚     âœ… FileTracker ç‹¬ç«‹äº‹åŠ¡æäº¤                                     â”‚   â”‚
â”‚   â”‚        â”‚                                                                     â”‚   â”‚
â”‚   â”‚        â”œâ”€â‘¢ AgentGit: ä¿å­˜çŠ¶æ€æ£€æŸ¥ç‚¹                                          â”‚   â”‚
â”‚   â”‚        â”‚     â””â”€â”€ checkpoint_repo.create(checkpoint) â†’ checkpoint_id         â”‚   â”‚
â”‚   â”‚        â”‚     âœ… AgentGit ç‹¬ç«‹äº‹åŠ¡æäº¤                                        â”‚   â”‚
â”‚   â”‚        â”‚                                                                     â”‚   â”‚
â”‚   â”‚        â””â”€â‘£ WTB: åŸå­å†™å…¥ä¸šåŠ¡æ•°æ® + Outbox                                    â”‚   â”‚
â”‚   â”‚              with SQLAlchemyUnitOfWork as uow:                               â”‚   â”‚
â”‚   â”‚                  uow.node_boundaries.add(boundary)                           â”‚   â”‚
â”‚   â”‚                  uow.checkpoint_files.add(CheckpointFile(                    â”‚   â”‚
â”‚   â”‚                      checkpoint_id=checkpoint_id,                            â”‚   â”‚
â”‚   â”‚                      file_commit_id=file_commit_id                           â”‚   â”‚
â”‚   â”‚                  ))                                                          â”‚   â”‚
â”‚   â”‚                  uow.outbox.add(OutboxEvent(                                 â”‚   â”‚
â”‚   â”‚                      event_type="FILE_COMMIT_VERIFY",                        â”‚   â”‚
â”‚   â”‚                      payload={                                               â”‚   â”‚
â”‚   â”‚                          "checkpoint_id": checkpoint_id,                     â”‚   â”‚
â”‚   â”‚                          "file_commit_id": file_commit_id,                   â”‚   â”‚
â”‚   â”‚                          "node_id": "train"                                  â”‚   â”‚
â”‚   â”‚                      }                                                       â”‚   â”‚
â”‚   â”‚                  ))                                                          â”‚   â”‚
â”‚   â”‚                  uow.commit()  # åŸå­æäº¤ï¼                                   â”‚   â”‚
â”‚   â”‚              âœ… WTB äº‹åŠ¡æäº¤                                                 â”‚   â”‚
â”‚   â”‚                                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                                      â”‚
â”‚   åå°éªŒè¯æµç¨‹ (Outbox Processor):                                                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                                              â”‚   â”‚
â”‚   â”‚   OutboxProcessor.process_once()                                             â”‚   â”‚
â”‚   â”‚        â”‚                                                                     â”‚   â”‚
â”‚   â”‚        â”œâ”€ è·å– pending äº‹ä»¶: FILE_COMMIT_VERIFY                             â”‚   â”‚
â”‚   â”‚        â”‚                                                                     â”‚   â”‚
â”‚   â”‚        â”œâ”€ éªŒè¯ AgentGit checkpoint å­˜åœ¨                                      â”‚   â”‚
â”‚   â”‚        â”‚     checkpoint = checkpoint_repo.get_by_id(checkpoint_id)          â”‚   â”‚
â”‚   â”‚        â”‚     assert checkpoint is not None                                   â”‚   â”‚
â”‚   â”‚        â”‚                                                                     â”‚   â”‚
â”‚   â”‚        â”œâ”€ éªŒè¯ FileTracker commit å­˜åœ¨                                       â”‚   â”‚
â”‚   â”‚        â”‚     commit = commit_repo.find_by_id(file_commit_id)                â”‚   â”‚
â”‚   â”‚        â”‚     assert commit is not None                                       â”‚   â”‚
â”‚   â”‚        â”‚                                                                     â”‚   â”‚
â”‚   â”‚        â”œâ”€ éªŒè¯å®é™…æ–‡ä»¶å­˜åœ¨                                                   â”‚   â”‚
â”‚   â”‚        â”‚     for memento in commit.mementos:                                â”‚   â”‚
â”‚   â”‚        â”‚         assert blob_repo.exists(memento.file_hash)                 â”‚   â”‚
â”‚   â”‚        â”‚                                                                     â”‚   â”‚
â”‚   â”‚        â””â”€ å…¨éƒ¨é€šè¿‡ â†’ æ ‡è®° Outbox ä¸º processed                                â”‚   â”‚
â”‚   â”‚                                                                              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. P0: Outbox Pattern å®ç°è®¾è®¡

### 2.1 Outbox è¡¨è®¾è®¡

```sql
-- WTB Database Schema Addition
-- File: wtb/infrastructure/database/migrations/002_add_outbox.sql

CREATE TABLE wtb_outbox (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    
    -- äº‹ä»¶æ ‡è¯†
    event_id        TEXT NOT NULL UNIQUE,          -- UUID, å¹‚ç­‰é”®
    event_type      TEXT NOT NULL,                 -- 'CHECKPOINT_CREATE', 'NODE_BOUNDARY_SYNC'
    aggregate_type  TEXT NOT NULL,                 -- 'Execution', 'NodeBoundary'
    aggregate_id    TEXT NOT NULL,                 -- execution_id æˆ– boundary_id
    
    -- äº‹ä»¶å†…å®¹
    payload         TEXT NOT NULL,                 -- JSON: åŒ…å«æ‰€æœ‰éœ€è¦åŒæ­¥çš„æ•°æ®
    
    -- çŠ¶æ€è·Ÿè¸ª
    status          TEXT NOT NULL DEFAULT 'pending',  -- 'pending', 'processing', 'processed', 'failed'
    retry_count     INTEGER NOT NULL DEFAULT 0,
    max_retries     INTEGER NOT NULL DEFAULT 5,
    
    -- æ—¶é—´æˆ³
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    processed_at    TIMESTAMP NULL,
    last_error      TEXT NULL,
    
    -- ç´¢å¼•
    INDEX idx_outbox_status_created (status, created_at)
);
```

### 2.2 é¢†åŸŸæ¨¡å‹

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# wtb/domain/models/outbox.py
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from dataclasses import dataclass, field
from typing import Dict, Any, Optional
from datetime import datetime
from enum import Enum
import uuid
import json


class OutboxEventType(Enum):
    """Outbox äº‹ä»¶ç±»å‹"""
    # AgentGit ç›¸å…³
    CHECKPOINT_CREATE = "checkpoint_create"
    CHECKPOINT_VERIFY = "checkpoint_verify"
    NODE_BOUNDARY_SYNC = "node_boundary_sync"
    
    # FileTracker ç›¸å…³
    FILE_COMMIT_LINK = "file_commit_link"
    FILE_COMMIT_VERIFY = "file_commit_verify"    # éªŒè¯æ–‡ä»¶æäº¤å®Œæ•´æ€§
    FILE_BLOB_VERIFY = "file_blob_verify"        # éªŒè¯ Blob æ–‡ä»¶å­˜åœ¨
    
    # è·¨åº“è”åˆéªŒè¯
    CHECKPOINT_FILE_LINK_VERIFY = "checkpoint_file_link_verify"  # éªŒè¯ checkpoint â†” file_commit é“¾æ¥


class OutboxStatus(Enum):
    """Outbox äº‹ä»¶çŠ¶æ€"""
    PENDING = "pending"
    PROCESSING = "processing"
    PROCESSED = "processed"
    FAILED = "failed"


@dataclass
class OutboxEvent:
    """
    Outbox äº‹ä»¶å®ä½“ã€‚
    
    ç”¨äºè®°å½•éœ€è¦è·¨æ•°æ®åº“åŒæ­¥çš„æ“ä½œï¼Œç¡®ä¿æœ€ç»ˆä¸€è‡´æ€§ã€‚
    
    Design Philosophy:
    - ä¸ä¸šåŠ¡æ•°æ®åœ¨åŒä¸€äº‹åŠ¡ä¸­å†™å…¥
    - é€šè¿‡ event_id ä¿è¯å¹‚ç­‰æ€§
    - æ”¯æŒé‡è¯•å’Œé”™è¯¯è¿½è¸ª
    """
    
    id: Optional[int] = None
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    event_type: OutboxEventType = OutboxEventType.CHECKPOINT_CREATE
    aggregate_type: str = ""
    aggregate_id: str = ""
    payload: Dict[str, Any] = field(default_factory=dict)
    
    status: OutboxStatus = OutboxStatus.PENDING
    retry_count: int = 0
    max_retries: int = 5
    
    created_at: datetime = field(default_factory=datetime.now)
    processed_at: Optional[datetime] = None
    last_error: Optional[str] = None
    
    def can_retry(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡è¯•"""
        return (
            self.status in [OutboxStatus.PENDING, OutboxStatus.FAILED] 
            and self.retry_count < self.max_retries
        )
    
    def mark_processing(self) -> None:
        """æ ‡è®°ä¸ºå¤„ç†ä¸­"""
        self.status = OutboxStatus.PROCESSING
    
    def mark_processed(self) -> None:
        """æ ‡è®°ä¸ºå·²å¤„ç†"""
        self.status = OutboxStatus.PROCESSED
        self.processed_at = datetime.now()
    
    def mark_failed(self, error: str) -> None:
        """æ ‡è®°ä¸ºå¤±è´¥"""
        self.status = OutboxStatus.FAILED
        self.retry_count += 1
        self.last_error = error
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "event_id": self.event_id,
            "event_type": self.event_type.value,
            "aggregate_type": self.aggregate_type,
            "aggregate_id": self.aggregate_id,
            "payload": self.payload,
            "status": self.status.value,
            "retry_count": self.retry_count,
            "max_retries": self.max_retries,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "processed_at": self.processed_at.isoformat() if self.processed_at else None,
            "last_error": self.last_error,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "OutboxEvent":
        return cls(
            id=data.get("id"),
            event_id=data.get("event_id", str(uuid.uuid4())),
            event_type=OutboxEventType(data.get("event_type", "checkpoint_create")),
            aggregate_type=data.get("aggregate_type", ""),
            aggregate_id=data.get("aggregate_id", ""),
            payload=data.get("payload", {}),
            status=OutboxStatus(data.get("status", "pending")),
            retry_count=data.get("retry_count", 0),
            max_retries=data.get("max_retries", 5),
            created_at=datetime.fromisoformat(data["created_at"]) if data.get("created_at") else datetime.now(),
            processed_at=datetime.fromisoformat(data["processed_at"]) if data.get("processed_at") else None,
            last_error=data.get("last_error"),
        )
```

### 2.3 Outbox Repository æ¥å£

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# wtb/domain/interfaces/outbox_repository.py
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from abc import ABC, abstractmethod
from typing import List, Optional
from datetime import datetime

from wtb.domain.models.outbox import OutboxEvent, OutboxStatus


class IOutboxRepository(ABC):
    """Outbox ä»“å‚¨æ¥å£"""
    
    @abstractmethod
    def add(self, event: OutboxEvent) -> OutboxEvent:
        """æ·»åŠ æ–°äº‹ä»¶"""
        pass
    
    @abstractmethod
    def get_by_id(self, event_id: str) -> Optional[OutboxEvent]:
        """æ ¹æ® event_id è·å–äº‹ä»¶ï¼ˆå¹‚ç­‰æŸ¥è¯¢ï¼‰"""
        pass
    
    @abstractmethod
    def get_pending(self, limit: int = 100) -> List[OutboxEvent]:
        """è·å–å¾…å¤„ç†äº‹ä»¶ï¼ŒæŒ‰åˆ›å»ºæ—¶é—´æ’åº"""
        pass
    
    @abstractmethod
    def get_failed_for_retry(self, limit: int = 50) -> List[OutboxEvent]:
        """è·å–å¯é‡è¯•çš„å¤±è´¥äº‹ä»¶"""
        pass
    
    @abstractmethod
    def update(self, event: OutboxEvent) -> OutboxEvent:
        """æ›´æ–°äº‹ä»¶çŠ¶æ€"""
        pass
    
    @abstractmethod
    def delete_processed(self, before: datetime, limit: int = 1000) -> int:
        """æ¸…ç†å·²å¤„ç†çš„æ—§äº‹ä»¶"""
        pass
```

### 2.4 æ›´æ–° IUnitOfWork æ¥å£

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# wtb/domain/interfaces/unit_of_work.py (æ›´æ–°)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class IUnitOfWork(ABC):
    """
    Unit of Work pattern interface.
    
    å¢åŠ  outbox ä»“å‚¨ï¼Œæ”¯æŒ Outbox Patternã€‚
    """
    
    # WTB Core Repositories
    workflows: "IWorkflowRepository"
    executions: "IExecutionRepository"
    variants: "INodeVariantRepository"
    batch_tests: "IBatchTestRepository"
    evaluation_results: "IEvaluationResultRepository"
    
    # WTB-Specific Repositories (Anti-Corruption Layer)
    node_boundaries: "INodeBoundaryRepository"
    checkpoint_files: "ICheckpointFileRepository"
    
    # Outbox Pattern (NEW)
    outbox: "IOutboxRepository"  # ğŸ‘ˆ æ–°å¢
    
    # ... å…¶ä»–æ–¹æ³•ä¸å˜
```

### 2.5 Outbox Processor (Worker)

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# wtb/infrastructure/outbox/processor.py
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from typing import Callable, Dict, Optional
from datetime import datetime
import threading
import time
import logging

from wtb.domain.models.outbox import OutboxEvent, OutboxEventType, OutboxStatus
from wtb.infrastructure.database.unit_of_work import SQLAlchemyUnitOfWork

# AgentGit imports
from agentgit.database.repositories.checkpoint_repository import CheckpointRepository

logger = logging.getLogger(__name__)


class OutboxProcessor:
    """
    Outbox äº‹ä»¶å¤„ç†å™¨ã€‚
    
    èŒè´£ï¼š
    1. è½®è¯¢ Outbox è¡¨è·å–å¾…å¤„ç†äº‹ä»¶
    2. è°ƒç”¨å¯¹åº”çš„å¤„ç†å™¨æ‰§è¡Œè·¨åº“æ“ä½œ
    3. æ›´æ–°äº‹ä»¶çŠ¶æ€ï¼ˆæˆåŠŸ/å¤±è´¥ï¼‰
    4. æ”¯æŒä¼˜é›…å…³é—­
    
    Usage:
        processor = OutboxProcessor(
            wtb_db_url="sqlite:///data/wtb.db",
            agentgit_db_path="data/agentgit.db"
        )
        processor.start()  # åå°çº¿ç¨‹
        ...
        processor.stop()   # ä¼˜é›…å…³é—­
    """
    
    def __init__(
        self,
        wtb_db_url: str,
        agentgit_db_path: str,
        filetracker_connection=None,  # PostgreSQL connection for FileTracker
        blob_storage_path: Optional[str] = None,  # Path to objects/ directory
        poll_interval_seconds: float = 1.0,
        batch_size: int = 50,
    ):
        self._wtb_db_url = wtb_db_url
        self._agentgit_db_path = agentgit_db_path
        self._poll_interval = poll_interval_seconds
        self._batch_size = batch_size
        
        # AgentGit
        self._checkpoint_repo = CheckpointRepository(agentgit_db_path)
        
        # FileTracker (å¯é€‰)
        self._filetracker_connection = filetracker_connection
        self._blob_storage_path = blob_storage_path
        self._filetracker_enabled = filetracker_connection is not None
        
        self._running = False
        self._thread: Optional[threading.Thread] = None
        
        # äº‹ä»¶å¤„ç†å™¨æ˜ å°„
        self._handlers: Dict[OutboxEventType, Callable[[OutboxEvent], None]] = {
            # AgentGit ç›¸å…³
            OutboxEventType.CHECKPOINT_CREATE: self._handle_checkpoint_create,
            OutboxEventType.CHECKPOINT_VERIFY: self._handle_checkpoint_verify,
            OutboxEventType.NODE_BOUNDARY_SYNC: self._handle_node_boundary_sync,
            
            # FileTracker ç›¸å…³
            OutboxEventType.FILE_COMMIT_LINK: self._handle_file_commit_link,
            OutboxEventType.FILE_COMMIT_VERIFY: self._handle_file_commit_verify,
            OutboxEventType.FILE_BLOB_VERIFY: self._handle_file_blob_verify,
            
            # è·¨åº“è”åˆéªŒè¯
            OutboxEventType.CHECKPOINT_FILE_LINK_VERIFY: self._handle_checkpoint_file_link_verify,
        }
    
    def start(self) -> None:
        """å¯åŠ¨å¤„ç†å™¨ï¼ˆåå°çº¿ç¨‹ï¼‰"""
        if self._running:
            return
        
        self._running = True
        self._thread = threading.Thread(target=self._run_loop, daemon=True)
        self._thread.start()
        logger.info("OutboxProcessor started")
    
    def stop(self, timeout: float = 5.0) -> None:
        """åœæ­¢å¤„ç†å™¨"""
        self._running = False
        if self._thread:
            self._thread.join(timeout=timeout)
        logger.info("OutboxProcessor stopped")
    
    def process_once(self) -> int:
        """å¤„ç†ä¸€æ‰¹äº‹ä»¶ï¼ˆä¾›æµ‹è¯•ä½¿ç”¨ï¼‰"""
        return self._process_batch()
    
    def _run_loop(self) -> None:
        """ä¸»å¾ªç¯"""
        while self._running:
            try:
                processed = self._process_batch()
                if processed == 0:
                    # æ— äº‹ä»¶æ—¶ä¼‘çœ 
                    time.sleep(self._poll_interval)
            except Exception as e:
                logger.error(f"OutboxProcessor error: {e}")
                time.sleep(self._poll_interval * 2)  # é”™è¯¯æ—¶å»¶é•¿ä¼‘çœ 
    
    def _process_batch(self) -> int:
        """å¤„ç†ä¸€æ‰¹äº‹ä»¶"""
        processed = 0
        
        with SQLAlchemyUnitOfWork(self._wtb_db_url) as uow:
            # è·å–å¾…å¤„ç†äº‹ä»¶
            events = uow.outbox.get_pending(limit=self._batch_size)
            
            for event in events:
                try:
                    # æ ‡è®°å¤„ç†ä¸­
                    event.mark_processing()
                    uow.outbox.update(event)
                    uow.commit()
                    
                    # æ‰§è¡Œå¤„ç†ï¼ˆè·¨åº“æ“ä½œï¼‰
                    handler = self._handlers.get(event.event_type)
                    if handler:
                        handler(event)
                    else:
                        raise ValueError(f"Unknown event type: {event.event_type}")
                    
                    # æ ‡è®°æˆåŠŸ
                    event.mark_processed()
                    uow.outbox.update(event)
                    uow.commit()
                    processed += 1
                    
                except Exception as e:
                    logger.error(f"Failed to process event {event.event_id}: {e}")
                    event.mark_failed(str(e))
                    uow.outbox.update(event)
                    uow.commit()
        
        return processed
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Event Handlers
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _handle_checkpoint_create(self, event: OutboxEvent) -> None:
        """
        å¤„ç†æ£€æŸ¥ç‚¹åˆ›å»ºäº‹ä»¶ã€‚
        
        éªŒè¯ AgentGit ä¸­æ£€æŸ¥ç‚¹æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºã€‚
        """
        payload = event.payload
        checkpoint_id = payload.get("checkpoint_id")
        
        if checkpoint_id:
            # éªŒè¯æ£€æŸ¥ç‚¹å­˜åœ¨
            cp = self._checkpoint_repo.get_by_id(checkpoint_id)
            if not cp:
                raise ValueError(f"Checkpoint {checkpoint_id} not found in AgentGit")
        
        logger.info(f"Verified checkpoint {checkpoint_id} for event {event.event_id}")
    
    def _handle_checkpoint_verify(self, event: OutboxEvent) -> None:
        """éªŒè¯æ£€æŸ¥ç‚¹å®Œæ•´æ€§"""
        payload = event.payload
        checkpoint_id = payload.get("checkpoint_id")
        
        cp = self._checkpoint_repo.get_by_id(checkpoint_id)
        if not cp:
            raise ValueError(f"Checkpoint {checkpoint_id} missing")
        
        logger.info(f"Checkpoint {checkpoint_id} verified")
    
    def _handle_node_boundary_sync(self, event: OutboxEvent) -> None:
        """
        åŒæ­¥èŠ‚ç‚¹è¾¹ç•Œåˆ° AgentGit metadataã€‚
        
        ç¡®ä¿ AgentGit checkpoint çš„ metadata åŒ…å«æ­£ç¡®çš„ node_boundary ä¿¡æ¯ã€‚
        """
        payload = event.payload
        checkpoint_id = payload.get("exit_checkpoint_id")
        node_id = payload.get("node_id")
        
        if checkpoint_id:
            cp = self._checkpoint_repo.get_by_id(checkpoint_id)
            if cp:
                # æ›´æ–° metadata
                metadata = cp.metadata or {}
                metadata["wtb_node_boundary"] = {
                    "node_id": node_id,
                    "synced_at": datetime.now().isoformat(),
                }
                self._checkpoint_repo.update_checkpoint_metadata(checkpoint_id, metadata)
        
        logger.info(f"Node boundary synced for node {node_id}")
    
    def _handle_file_commit_link(self, event: OutboxEvent) -> None:
        """å¤„ç†æ–‡ä»¶æäº¤é“¾æ¥ï¼ˆæ—§ç‰ˆï¼Œä¿ç•™å…¼å®¹ï¼‰"""
        self._handle_file_commit_verify(event)
    
    def _handle_file_commit_verify(self, event: OutboxEvent) -> None:
        """
        éªŒè¯ FileTracker commit å­˜åœ¨ä¸”å®Œæ•´ã€‚
        
        æ£€æŸ¥é¡¹ï¼š
        1. commit è®°å½•å­˜åœ¨äº FileTracker æ•°æ®åº“
        2. æ‰€æœ‰å…³è”çš„ mementos å­˜åœ¨
        3. æ‰€æœ‰å¼•ç”¨çš„ blob æ–‡ä»¶å­˜åœ¨äºæ–‡ä»¶ç³»ç»Ÿ
        """
        payload = event.payload
        file_commit_id = payload.get("file_commit_id")
        
        if not file_commit_id:
            logger.warning(f"No file_commit_id in event {event.event_id}")
            return
        
        # è¿æ¥ FileTracker æ•°æ®åº“
        # TODO: ä»é…ç½®è·å–è¿æ¥ä¿¡æ¯
        from FileTracker.Repository.CommitRepository import CommitRepository
        from FileTracker.Repository.BlobRepository import BlobRepository
        
        commit_repo = CommitRepository(self._filetracker_connection)
        blob_repo = BlobRepository(self._filetracker_connection, self._blob_storage_path)
        
        # éªŒè¯ commit å­˜åœ¨
        commit = commit_repo.find_by_id(file_commit_id)
        if not commit:
            raise ValueError(f"FileTracker commit {file_commit_id} not found")
        
        # éªŒè¯æ‰€æœ‰ blob å­˜åœ¨
        for memento in commit.mementos:
            if not blob_repo.exists(memento.file_hash):
                raise ValueError(f"Blob {memento.file_hash} missing for file {memento.file_path}")
        
        logger.info(f"FileTracker commit {file_commit_id} verified: {len(commit.mementos)} files")
    
    def _handle_file_blob_verify(self, event: OutboxEvent) -> None:
        """éªŒè¯å•ä¸ª Blob æ–‡ä»¶å­˜åœ¨"""
        payload = event.payload
        file_hash = payload.get("file_hash")
        
        from FileTracker.Repository.BlobRepository import BlobRepository
        blob_repo = BlobRepository(self._filetracker_connection, self._blob_storage_path)
        
        if not blob_repo.exists(file_hash):
            raise ValueError(f"Blob {file_hash} not found in storage")
        
        logger.info(f"Blob {file_hash} verified")
    
    def _handle_checkpoint_file_link_verify(self, event: OutboxEvent) -> None:
        """
        éªŒè¯ Checkpoint â†” FileTracker é“¾æ¥å®Œæ•´æ€§ã€‚
        
        è¿™æ˜¯æœ€å…¨é¢çš„éªŒè¯ï¼Œç¡®ä¿ä¸‰ä¸ªç³»ç»Ÿçš„æ•°æ®ä¸€è‡´ï¼š
        1. AgentGit checkpoint å­˜åœ¨
        2. FileTracker commit å­˜åœ¨
        3. WTB checkpoint_files é“¾æ¥è®°å½•å­˜åœ¨
        4. æ‰€æœ‰ blob æ–‡ä»¶å­˜åœ¨
        """
        payload = event.payload
        checkpoint_id = payload.get("checkpoint_id")
        file_commit_id = payload.get("file_commit_id")
        
        # éªŒè¯ AgentGit checkpoint
        cp = self._checkpoint_repo.get_by_id(checkpoint_id)
        if not cp:
            raise ValueError(f"AgentGit checkpoint {checkpoint_id} not found")
        
        # éªŒè¯ WTB é“¾æ¥è®°å½•
        with SQLAlchemyUnitOfWork(self._wtb_db_url) as uow:
            link = uow.checkpoint_files.find_by_checkpoint(checkpoint_id)
            if not link:
                raise ValueError(f"WTB checkpoint_files link not found for checkpoint {checkpoint_id}")
            
            if link.file_commit_id != file_commit_id:
                raise ValueError(f"file_commit_id mismatch: expected {file_commit_id}, got {link.file_commit_id}")
        
        # éªŒè¯ FileTracker
        from FileTracker.Repository.CommitRepository import CommitRepository
        from FileTracker.Repository.BlobRepository import BlobRepository
        
        commit_repo = CommitRepository(self._filetracker_connection)
        blob_repo = BlobRepository(self._filetracker_connection, self._blob_storage_path)
        
        commit = commit_repo.find_by_id(file_commit_id)
        if not commit:
            raise ValueError(f"FileTracker commit {file_commit_id} not found")
        
        for memento in commit.mementos:
            if not blob_repo.exists(memento.file_hash):
                raise ValueError(f"Blob {memento.file_hash} missing")
        
        logger.info(f"Checkpoint-File link verified: checkpoint={checkpoint_id}, commit={file_commit_id}")
```

### 2.6 ä¿®æ”¹ AgentGitStateAdapter (ä½¿ç”¨ Outbox)

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# wtb/infrastructure/adapters/agentgit_state_adapter.py (ä¿®æ”¹ç‰ˆ)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AgentGitStateAdapter(IStateAdapter):
    """
    ä½¿ç”¨ Outbox Pattern çš„çŠ¶æ€é€‚é…å™¨ã€‚
    
    å…³é”®æ”¹å˜:
    - æ‰€æœ‰è·¨åº“æ“ä½œå…ˆå†™å…¥ Outbox
    - Outbox Processor åå°å¤„ç†
    - ä¿è¯æœ€ç»ˆä¸€è‡´æ€§
    """
    
    def save_checkpoint_with_boundary(
        self,
        state: ExecutionState,
        node_id: str,
        trigger: CheckpointTrigger,
        is_node_entry: bool = False,
        is_node_exit: bool = False,
        tool_name: Optional[str] = None,
        name: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> int:
        """
        åŸå­æ€§ä¿å­˜æ£€æŸ¥ç‚¹å’Œè¾¹ç•Œä¿¡æ¯ã€‚
        
        å®ç° Outbox Patternï¼š
        1. å†™å…¥ AgentGit checkpointï¼ˆç«‹å³ï¼‰
        2. å†™å…¥ WTB node_boundary + outbox äº‹ä»¶ï¼ˆåŒä¸€äº‹åŠ¡ï¼‰
        3. Outbox Processor åç»­åŒæ­¥éªŒè¯
        """
        if not self._current_session:
            raise RuntimeError("No active session. Call initialize_session first.")
        
        # Step 1: åˆ›å»º AgentGit checkpoint (ç«‹å³æ‰§è¡Œ)
        checkpoint_id = self._create_agentgit_checkpoint(
            state, node_id, trigger, tool_name, name, metadata
        )
        
        # Step 2: å†™å…¥ WTB æ•°æ® + Outbox (åŒä¸€äº‹åŠ¡)
        with SQLAlchemyUnitOfWork(self._wtb_db_url) as uow:
            # åˆ›å»ºæˆ–æ›´æ–° node_boundary
            if is_node_entry:
                boundary = NodeBoundary(
                    execution_id=self._current_execution_id or "",
                    internal_session_id=self._current_session.id,
                    node_id=node_id,
                    entry_checkpoint_id=checkpoint_id,
                    node_status="started",
                )
                uow.node_boundaries.add(boundary)
            
            if is_node_exit:
                boundary = uow.node_boundaries.find_by_node(
                    self._current_session.id, node_id
                )
                if boundary:
                    boundary.exit_checkpoint_id = checkpoint_id
                    boundary.node_status = "completed"
                    boundary.completed_at = datetime.now()
                    uow.node_boundaries.update(boundary)
            
            # åˆ›å»º Outbox äº‹ä»¶ï¼ˆåŒä¸€äº‹åŠ¡ï¼ï¼‰
            outbox_event = OutboxEvent(
                event_type=OutboxEventType.CHECKPOINT_VERIFY,
                aggregate_type="Execution",
                aggregate_id=self._current_execution_id or "",
                payload={
                    "checkpoint_id": checkpoint_id,
                    "node_id": node_id,
                    "is_entry": is_node_entry,
                    "is_exit": is_node_exit,
                    "internal_session_id": self._current_session.id,
                }
            )
            uow.outbox.add(outbox_event)
            
            # åŸå­æäº¤
            uow.commit()
        
        return checkpoint_id
    
    def _create_agentgit_checkpoint(
        self,
        state: ExecutionState,
        node_id: str,
        trigger: CheckpointTrigger,
        tool_name: Optional[str],
        name: Optional[str],
        metadata: Optional[Dict[str, Any]]
    ) -> int:
        """ä»…åˆ›å»º AgentGit checkpoint (å†…éƒ¨æ–¹æ³•)"""
        # ... åŸæœ‰çš„ checkpoint åˆ›å»ºé€»è¾‘
        # æ›´æ–° session
        self._current_session.current_node_id = node_id
        self._current_session.workflow_variables = dict(state.workflow_variables)
        self._current_session.execution_path = list(state.execution_path)
        self._current_session.session_state = state.to_dict()
        self._session_repo.update(self._current_session)
        
        # æ„å»º metadata
        tool_position = self._tool_manager.get_tool_track_position()
        cp_metadata = metadata or {}
        cp_metadata.update({
            "trigger_type": trigger.value,
            "node_id": node_id,
            "tool_name": tool_name,
            "tool_track_position": tool_position,
            "wtb_execution_id": self._current_execution_id,
            "mdp_state": {
                "current_node_id": state.current_node_id,
                "workflow_variables": state.workflow_variables,
                "execution_path": state.execution_path,
            }
        })
        
        # åˆ›å»º checkpoint
        checkpoint = Checkpoint(
            id=None,
            internal_session_id=self._current_session.id,
            checkpoint_name=name,
            session_state=state.to_dict(),
            is_auto=(trigger != CheckpointTrigger.USER_REQUEST),
            created_at=datetime.now(),
            metadata=cp_metadata,
            tool_invocations=[inv.to_dict() for inv in self._tool_manager.get_tool_track()],
        )
        
        saved_cp = self._checkpoint_repo.create(checkpoint)
        return saved_cp.id
```

---

## 3. P0: IntegrityChecker è®¾è®¡

### 3.1 è®¾è®¡ç›®æ ‡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    IntegrityChecker è®¾è®¡ç›®æ ‡                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  æ£€æŸ¥é¡¹:                                                                         â”‚
â”‚  â•â•â•â•â•â•                                                                          â”‚
â”‚                                                                                  â”‚
â”‚  1. æ‚¬ç©ºå¼•ç”¨ (Dangling References)                                              â”‚
â”‚     â€¢ node_boundaries.entry_checkpoint_id â†’ agentgit.checkpoints               â”‚
â”‚     â€¢ node_boundaries.exit_checkpoint_id â†’ agentgit.checkpoints                â”‚
â”‚     â€¢ checkpoint_files.file_commit_id â†’ filetracker.commits                    â”‚
â”‚                                                                                  â”‚
â”‚  2. å­¤å„¿æ•°æ® (Orphan Data)                                                       â”‚
â”‚     â€¢ AgentGit checkpoints æ²¡æœ‰å¯¹åº”çš„ WTB execution                             â”‚
â”‚     â€¢ FileTracker commits æ²¡æœ‰è¢«ä»»ä½• checkpoint å¼•ç”¨                            â”‚
â”‚                                                                                  â”‚
â”‚  3. çŠ¶æ€ä¸ä¸€è‡´ (State Inconsistency)                                            â”‚
â”‚     â€¢ node_boundary.status ä¸ checkpoint æ•°é‡ä¸ç¬¦                               â”‚
â”‚     â€¢ Outbox äº‹ä»¶é•¿æœŸå¤„äº pending/failed                                        â”‚
â”‚                                                                                  â”‚
â”‚  æ“ä½œæ¨¡å¼:                                                                       â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•                                                                      â”‚
â”‚                                                                                  â”‚
â”‚  â€¢ CHECK:  åªæ£€æŸ¥ï¼Œè¿”å›æŠ¥å‘Š                                                      â”‚
â”‚  â€¢ REPAIR: å°è¯•ä¿®å¤ï¼ˆåˆ›å»ºç¼ºå¤±å¼•ç”¨ / åˆ é™¤å­¤å„¿ï¼‰                                   â”‚
â”‚  â€¢ AUDIT:  è®°å½•åˆ°å®¡è®¡æ—¥å¿—                                                        â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 é¢†åŸŸæ¨¡å‹

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# wtb/domain/models/integrity.py
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum


class IntegrityIssueType(Enum):
    """å®Œæ•´æ€§é—®é¢˜ç±»å‹"""
    DANGLING_REFERENCE = "dangling_reference"     # æ‚¬ç©ºå¼•ç”¨
    ORPHAN_CHECKPOINT = "orphan_checkpoint"       # å­¤å„¿æ£€æŸ¥ç‚¹
    ORPHAN_FILE_COMMIT = "orphan_file_commit"     # å­¤å„¿æ–‡ä»¶æäº¤
    STATE_MISMATCH = "state_mismatch"             # çŠ¶æ€ä¸åŒ¹é…
    OUTBOX_STUCK = "outbox_stuck"                 # Outbox å¡ä½


class IntegritySeverity(Enum):
    """é—®é¢˜ä¸¥é‡ç¨‹åº¦"""
    CRITICAL = "critical"   # å¿…é¡»ä¿®å¤ï¼Œå½±å“åŠŸèƒ½
    WARNING = "warning"     # å»ºè®®ä¿®å¤ï¼Œå¯èƒ½å¯¼è‡´é—®é¢˜
    INFO = "info"           # ä»…ä¾›å‚è€ƒ


class RepairAction(Enum):
    """ä¿®å¤åŠ¨ä½œ"""
    DELETE_ORPHAN = "delete_orphan"
    CREATE_MISSING = "create_missing"
    UPDATE_STATUS = "update_status"
    RETRY_OUTBOX = "retry_outbox"
    MANUAL_REQUIRED = "manual_required"


@dataclass
class IntegrityIssue:
    """å•ä¸ªå®Œæ•´æ€§é—®é¢˜"""
    
    issue_type: IntegrityIssueType
    severity: IntegritySeverity
    
    # ä½ç½®ä¿¡æ¯
    source_table: str
    source_id: str
    target_table: Optional[str] = None
    target_id: Optional[str] = None
    
    # è¯¦æƒ…
    message: str = ""
    details: Dict[str, Any] = field(default_factory=dict)
    
    # ä¿®å¤å»ºè®®
    suggested_action: RepairAction = RepairAction.MANUAL_REQUIRED
    auto_repairable: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "issue_type": self.issue_type.value,
            "severity": self.severity.value,
            "source_table": self.source_table,
            "source_id": self.source_id,
            "target_table": self.target_table,
            "target_id": self.target_id,
            "message": self.message,
            "details": self.details,
            "suggested_action": self.suggested_action.value,
            "auto_repairable": self.auto_repairable,
        }


@dataclass
class IntegrityReport:
    """å®Œæ•´æ€§æ£€æŸ¥æŠ¥å‘Š"""
    
    checked_at: datetime = field(default_factory=datetime.now)
    duration_ms: float = 0
    
    # ç»Ÿè®¡
    total_checked: int = 0
    issues_found: int = 0
    critical_count: int = 0
    warning_count: int = 0
    info_count: int = 0
    
    # é—®é¢˜åˆ—è¡¨
    issues: List[IntegrityIssue] = field(default_factory=list)
    
    # ä¿®å¤ç»“æœ
    repaired_count: int = 0
    repair_failed_count: int = 0
    
    def add_issue(self, issue: IntegrityIssue) -> None:
        self.issues.append(issue)
        self.issues_found += 1
        
        if issue.severity == IntegritySeverity.CRITICAL:
            self.critical_count += 1
        elif issue.severity == IntegritySeverity.WARNING:
            self.warning_count += 1
        else:
            self.info_count += 1
    
    @property
    def is_healthy(self) -> bool:
        return self.critical_count == 0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "checked_at": self.checked_at.isoformat(),
            "duration_ms": self.duration_ms,
            "total_checked": self.total_checked,
            "issues_found": self.issues_found,
            "critical_count": self.critical_count,
            "warning_count": self.warning_count,
            "info_count": self.info_count,
            "is_healthy": self.is_healthy,
            "issues": [i.to_dict() for i in self.issues],
            "repaired_count": self.repaired_count,
            "repair_failed_count": self.repair_failed_count,
        }
    
    def summary(self) -> str:
        """ç”Ÿæˆäººç±»å¯è¯»çš„æ‘˜è¦"""
        status = "âœ… HEALTHY" if self.is_healthy else "âŒ UNHEALTHY"
        return (
            f"{status}\n"
            f"Checked: {self.total_checked} items in {self.duration_ms:.2f}ms\n"
            f"Issues: {self.issues_found} "
            f"(Critical: {self.critical_count}, Warning: {self.warning_count}, Info: {self.info_count})\n"
            f"Repaired: {self.repaired_count}, Failed: {self.repair_failed_count}"
        )
```

### 3.3 IntegrityChecker å®ç°

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# wtb/infrastructure/integrity/checker.py
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from typing import Optional
from datetime import datetime, timedelta
import logging
import time

from wtb.domain.models.integrity import (
    IntegrityReport, IntegrityIssue, IntegrityIssueType,
    IntegritySeverity, RepairAction
)
from wtb.infrastructure.database.unit_of_work import SQLAlchemyUnitOfWork

# AgentGit imports
from agentgit.database.repositories.checkpoint_repository import CheckpointRepository
from agentgit.database.repositories.internal_session_repository import InternalSessionRepository

logger = logging.getLogger(__name__)


class IntegrityChecker:
    """
    è·¨æ•°æ®åº“å®Œæ•´æ€§æ£€æŸ¥å™¨ï¼ˆä¸‰åº“ç‰ˆæœ¬ï¼‰ã€‚
    
    æ£€æŸ¥ WTB â†” AgentGit â†” FileTracker ä¹‹é—´çš„å¼•ç”¨ä¸€è‡´æ€§ã€‚
    
    Usage:
        # ä»…æ£€æŸ¥ WTB + AgentGit
        checker = IntegrityChecker(
            wtb_db_url="sqlite:///data/wtb.db",
            agentgit_db_path="data/agentgit.db"
        )
        
        # å®Œæ•´ä¸‰åº“æ£€æŸ¥
        checker = IntegrityChecker(
            wtb_db_url="sqlite:///data/wtb.db",
            agentgit_db_path="data/agentgit.db",
            filetracker_connection=pg_connection,
            blob_storage_path="./storage/objects"
        )
        
        report = checker.check()
        print(report.summary())
    """
    
    def __init__(
        self,
        wtb_db_url: str,
        agentgit_db_path: str,
        filetracker_connection=None,  # PostgreSQL connection for FileTracker
        blob_storage_path: Optional[str] = None,  # Path to objects/ directory
    ):
        self._wtb_db_url = wtb_db_url
        self._agentgit_db_path = agentgit_db_path
        
        # FileTracker é…ç½®
        self._filetracker_connection = filetracker_connection
        self._blob_storage_path = blob_storage_path
        self._filetracker_enabled = filetracker_connection is not None
        
        # AgentGit repositories
        self._checkpoint_repo = CheckpointRepository(agentgit_db_path)
        self._session_repo = InternalSessionRepository(agentgit_db_path)
    
    def check(self) -> IntegrityReport:
        """æ‰§è¡Œå®Œæ•´æ€§æ£€æŸ¥"""
        start_time = time.time()
        report = IntegrityReport()
        
        # æ£€æŸ¥å„ç±»é—®é¢˜
        self._check_node_boundary_references(report)
        self._check_checkpoint_file_references(report)
        self._check_orphan_checkpoints(report)
        self._check_outbox_status(report)
        
        report.duration_ms = (time.time() - start_time) * 1000
        return report
    
    def check_and_repair(self) -> IntegrityReport:
        """æ‰§è¡Œå®Œæ•´æ€§æ£€æŸ¥å¹¶å°è¯•è‡ªåŠ¨ä¿®å¤"""
        report = self.check()
        
        for issue in report.issues:
            if issue.auto_repairable:
                try:
                    self._repair_issue(issue)
                    report.repaired_count += 1
                except Exception as e:
                    logger.error(f"Failed to repair issue: {e}")
                    report.repair_failed_count += 1
        
        return report
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Check Methods
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _check_node_boundary_references(self, report: IntegrityReport) -> None:
        """æ£€æŸ¥ node_boundaries è¡¨ä¸­çš„ checkpoint å¼•ç”¨"""
        with SQLAlchemyUnitOfWork(self._wtb_db_url) as uow:
            # è·å–æ‰€æœ‰ node_boundaries
            # æ³¨æ„ï¼šè¿™é‡Œå‡è®¾æœ‰ list_all æ–¹æ³•ï¼Œå®é™…éœ€è¦å®ç°
            all_boundaries = self._get_all_boundaries(uow)
            report.total_checked += len(all_boundaries)
            
            for boundary in all_boundaries:
                # æ£€æŸ¥ entry_checkpoint_id
                if boundary.entry_checkpoint_id:
                    cp = self._checkpoint_repo.get_by_id(boundary.entry_checkpoint_id)
                    if not cp:
                        report.add_issue(IntegrityIssue(
                            issue_type=IntegrityIssueType.DANGLING_REFERENCE,
                            severity=IntegritySeverity.CRITICAL,
                            source_table="wtb_node_boundaries",
                            source_id=str(boundary.id),
                            target_table="checkpoints",
                            target_id=str(boundary.entry_checkpoint_id),
                            message=f"Node boundary {boundary.id} references non-existent entry checkpoint {boundary.entry_checkpoint_id}",
                            details={
                                "node_id": boundary.node_id,
                                "execution_id": boundary.execution_id,
                            },
                            suggested_action=RepairAction.DELETE_ORPHAN,
                            auto_repairable=True,
                        ))
                
                # æ£€æŸ¥ exit_checkpoint_id
                if boundary.exit_checkpoint_id:
                    cp = self._checkpoint_repo.get_by_id(boundary.exit_checkpoint_id)
                    if not cp:
                        report.add_issue(IntegrityIssue(
                            issue_type=IntegrityIssueType.DANGLING_REFERENCE,
                            severity=IntegritySeverity.CRITICAL,
                            source_table="wtb_node_boundaries",
                            source_id=str(boundary.id),
                            target_table="checkpoints",
                            target_id=str(boundary.exit_checkpoint_id),
                            message=f"Node boundary {boundary.id} references non-existent exit checkpoint {boundary.exit_checkpoint_id}",
                            suggested_action=RepairAction.UPDATE_STATUS,
                            auto_repairable=True,
                        ))
    
    def _check_checkpoint_file_references(self, report: IntegrityReport) -> None:
        """æ£€æŸ¥ checkpoint_files è¡¨ä¸­çš„å¼•ç”¨ï¼ˆä¸‰åº“å®Œæ•´æ€§ï¼‰"""
        with SQLAlchemyUnitOfWork(self._wtb_db_url) as uow:
            all_links = self._get_all_checkpoint_files(uow)
            report.total_checked += len(all_links)
            
            for link in all_links:
                # æ£€æŸ¥ 1: checkpoint_id æ˜¯å¦åœ¨ AgentGit ä¸­å­˜åœ¨
                cp = self._checkpoint_repo.get_by_id(link.checkpoint_id)
                if not cp:
                    report.add_issue(IntegrityIssue(
                        issue_type=IntegrityIssueType.DANGLING_REFERENCE,
                        severity=IntegritySeverity.CRITICAL,
                        source_table="wtb_checkpoint_files",
                        source_id=str(link.id),
                        target_table="agentgit.checkpoints",
                        target_id=str(link.checkpoint_id),
                        message=f"Checkpoint file link references non-existent AgentGit checkpoint {link.checkpoint_id}",
                        suggested_action=RepairAction.DELETE_ORPHAN,
                        auto_repairable=True,
                    ))
                    continue  # è·³è¿‡åç»­ FileTracker æ£€æŸ¥
                
                # æ£€æŸ¥ 2: file_commit_id æ˜¯å¦åœ¨ FileTracker ä¸­å­˜åœ¨
                if self._filetracker_enabled:
                    self._check_filetracker_commit(report, link)
    
    def _check_filetracker_commit(self, report: IntegrityReport, link) -> None:
        """æ£€æŸ¥ FileTracker commit å®Œæ•´æ€§"""
        try:
            from FileTracker.Repository.CommitRepository import CommitRepository
            from FileTracker.Repository.BlobRepository import BlobRepository
            
            commit_repo = CommitRepository(self._filetracker_connection)
            blob_repo = BlobRepository(self._filetracker_connection, self._blob_storage_path)
            
            # æ£€æŸ¥ commit æ˜¯å¦å­˜åœ¨
            commit = commit_repo.find_by_id(link.file_commit_id)
            if not commit:
                report.add_issue(IntegrityIssue(
                    issue_type=IntegrityIssueType.DANGLING_REFERENCE,
                    severity=IntegritySeverity.CRITICAL,
                    source_table="wtb_checkpoint_files",
                    source_id=str(link.id),
                    target_table="filetracker.commits",
                    target_id=link.file_commit_id,
                    message=f"Checkpoint file link references non-existent FileTracker commit {link.file_commit_id}",
                    details={
                        "checkpoint_id": link.checkpoint_id,
                    },
                    suggested_action=RepairAction.DELETE_ORPHAN,
                    auto_repairable=True,
                ))
                return
            
            # æ£€æŸ¥æ‰€æœ‰ blob æ˜¯å¦å­˜åœ¨
            missing_blobs = []
            for memento in commit.mementos:
                if not blob_repo.exists(memento.file_hash):
                    missing_blobs.append({
                        "file_path": memento.file_path,
                        "file_hash": memento.file_hash,
                    })
            
            if missing_blobs:
                report.add_issue(IntegrityIssue(
                    issue_type=IntegrityIssueType.ORPHAN_FILE_COMMIT,
                    severity=IntegritySeverity.CRITICAL,
                    source_table="filetracker.commits",
                    source_id=link.file_commit_id,
                    target_table="filetracker.file_blobs",
                    message=f"FileTracker commit {link.file_commit_id} has {len(missing_blobs)} missing blob(s)",
                    details={
                        "missing_blobs": missing_blobs,
                        "checkpoint_id": link.checkpoint_id,
                    },
                    suggested_action=RepairAction.MANUAL_REQUIRED,
                    auto_repairable=False,  # æ–‡ä»¶ä¸¢å¤±æ— æ³•è‡ªåŠ¨ä¿®å¤
                ))
        
        except ImportError:
            logger.warning("FileTracker not available, skipping file commit checks")
        except Exception as e:
            logger.error(f"Error checking FileTracker commit: {e}")
    
    def _check_orphan_checkpoints(self, report: IntegrityReport) -> None:
        """æ£€æŸ¥ AgentGit ä¸­çš„å­¤å„¿æ£€æŸ¥ç‚¹"""
        # è·å–æ‰€æœ‰ WTB ç›¸å…³çš„ checkpoint IDs
        wtb_checkpoint_ids = set()
        
        with SQLAlchemyUnitOfWork(self._wtb_db_url) as uow:
            for boundary in self._get_all_boundaries(uow):
                if boundary.entry_checkpoint_id:
                    wtb_checkpoint_ids.add(boundary.entry_checkpoint_id)
                if boundary.exit_checkpoint_id:
                    wtb_checkpoint_ids.add(boundary.exit_checkpoint_id)
        
        # è·å–æ‰€æœ‰ AgentGit checkpoints (å¸¦ WTB metadata)
        # æ³¨æ„ï¼šè¿™éœ€è¦ AgentGit æ”¯æŒæŒ‰ metadata æŸ¥è¯¢
        # ç®€åŒ–å¤„ç†ï¼šæ£€æŸ¥æ‰€æœ‰ checkpoints
        all_checkpoints = self._get_all_wtb_checkpoints()
        report.total_checked += len(all_checkpoints)
        
        for cp in all_checkpoints:
            if cp.id not in wtb_checkpoint_ids:
                # æ£€æŸ¥æ˜¯å¦çœŸçš„æ˜¯ WTB åˆ›å»ºçš„
                metadata = cp.metadata or {}
                if metadata.get("wtb_execution_id"):
                    report.add_issue(IntegrityIssue(
                        issue_type=IntegrityIssueType.ORPHAN_CHECKPOINT,
                        severity=IntegritySeverity.INFO,
                        source_table="checkpoints",
                        source_id=str(cp.id),
                        message=f"Checkpoint {cp.id} not referenced by any WTB node boundary",
                        details={
                            "execution_id": metadata.get("wtb_execution_id"),
                            "created_at": cp.created_at.isoformat() if cp.created_at else None,
                        },
                        suggested_action=RepairAction.MANUAL_REQUIRED,
                        auto_repairable=False,  # éœ€è¦äººå·¥ç¡®è®¤æ˜¯å¦åˆ é™¤
                    ))
    
    def _check_outbox_status(self, report: IntegrityReport) -> None:
        """æ£€æŸ¥ Outbox ä¸­å¡ä½çš„äº‹ä»¶"""
        with SQLAlchemyUnitOfWork(self._wtb_db_url) as uow:
            # è·å–è¶…è¿‡1å°æ—¶æœªå¤„ç†çš„ pending äº‹ä»¶
            stuck_threshold = datetime.now() - timedelta(hours=1)
            stuck_events = uow.outbox.get_pending(limit=100)
            
            for event in stuck_events:
                if event.created_at < stuck_threshold:
                    report.add_issue(IntegrityIssue(
                        issue_type=IntegrityIssueType.OUTBOX_STUCK,
                        severity=IntegritySeverity.WARNING,
                        source_table="wtb_outbox",
                        source_id=event.event_id,
                        message=f"Outbox event stuck for over 1 hour",
                        details={
                            "event_type": event.event_type.value,
                            "created_at": event.created_at.isoformat(),
                            "retry_count": event.retry_count,
                        },
                        suggested_action=RepairAction.RETRY_OUTBOX,
                        auto_repairable=True,
                    ))
            
            # è·å–å¤±è´¥æ¬¡æ•°è¿‡å¤šçš„äº‹ä»¶
            failed_events = uow.outbox.get_failed_for_retry(limit=100)
            for event in failed_events:
                if not event.can_retry():
                    report.add_issue(IntegrityIssue(
                        issue_type=IntegrityIssueType.OUTBOX_STUCK,
                        severity=IntegritySeverity.CRITICAL,
                        source_table="wtb_outbox",
                        source_id=event.event_id,
                        message=f"Outbox event exceeded max retries",
                        details={
                            "event_type": event.event_type.value,
                            "last_error": event.last_error,
                            "retry_count": event.retry_count,
                        },
                        suggested_action=RepairAction.MANUAL_REQUIRED,
                        auto_repairable=False,
                    ))
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Repair Methods
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _repair_issue(self, issue: IntegrityIssue) -> None:
        """ä¿®å¤å•ä¸ªé—®é¢˜"""
        if issue.suggested_action == RepairAction.DELETE_ORPHAN:
            self._delete_orphan(issue)
        elif issue.suggested_action == RepairAction.UPDATE_STATUS:
            self._update_status(issue)
        elif issue.suggested_action == RepairAction.RETRY_OUTBOX:
            self._retry_outbox(issue)
        else:
            raise ValueError(f"Cannot auto-repair: {issue.suggested_action}")
    
    def _delete_orphan(self, issue: IntegrityIssue) -> None:
        """åˆ é™¤å­¤å„¿è®°å½•"""
        with SQLAlchemyUnitOfWork(self._wtb_db_url) as uow:
            if issue.source_table == "wtb_node_boundaries":
                uow.node_boundaries.delete(int(issue.source_id))
            elif issue.source_table == "wtb_checkpoint_files":
                uow.checkpoint_files.delete(int(issue.source_id))
            uow.commit()
        
        logger.info(f"Deleted orphan record: {issue.source_table}/{issue.source_id}")
    
    def _update_status(self, issue: IntegrityIssue) -> None:
        """æ›´æ–°çŠ¶æ€ï¼ˆæ¸…é™¤æ— æ•ˆå¼•ç”¨ï¼‰"""
        with SQLAlchemyUnitOfWork(self._wtb_db_url) as uow:
            if issue.source_table == "wtb_node_boundaries":
                boundary = uow.node_boundaries.get(int(issue.source_id))
                if boundary:
                    # æ¸…é™¤æ— æ•ˆçš„ checkpoint å¼•ç”¨
                    if "exit" in issue.message:
                        boundary.exit_checkpoint_id = None
                        boundary.node_status = "incomplete"
                    if "entry" in issue.message:
                        boundary.entry_checkpoint_id = None
                    uow.node_boundaries.update(boundary)
            uow.commit()
        
        logger.info(f"Updated status for: {issue.source_table}/{issue.source_id}")
    
    def _retry_outbox(self, issue: IntegrityIssue) -> None:
        """é‡è¯• Outbox äº‹ä»¶"""
        with SQLAlchemyUnitOfWork(self._wtb_db_url) as uow:
            event = uow.outbox.get_by_id(issue.source_id)
            if event:
                event.status = OutboxStatus.PENDING
                event.retry_count = 0  # é‡ç½®é‡è¯•è®¡æ•°
                uow.outbox.update(event)
            uow.commit()
        
        logger.info(f"Reset outbox event for retry: {issue.source_id}")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Helper Methods
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _get_all_boundaries(self, uow) -> list:
        """è·å–æ‰€æœ‰ node_boundariesï¼ˆéœ€è¦åœ¨ repository ä¸­å®ç°ï¼‰"""
        # TODO: æ·»åŠ  list_all æ–¹æ³•åˆ° INodeBoundaryRepository
        return getattr(uow.node_boundaries, 'list_all', lambda: [])()
    
    def _get_all_checkpoint_files(self, uow) -> list:
        """è·å–æ‰€æœ‰ checkpoint_files"""
        return getattr(uow.checkpoint_files, 'list_all', lambda: [])()
    
    def _get_all_wtb_checkpoints(self) -> list:
        """è·å–æ‰€æœ‰ WTB åˆ›å»ºçš„ checkpoints"""
        # TODO: éœ€è¦ AgentGit æ”¯æŒæŒ‰ metadata è¿‡æ»¤
        return []
```

### 3.4 CLI å·¥å…·

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# wtb/cli/integrity.py
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import click
import json
from wtb.infrastructure.integrity.checker import IntegrityChecker
from wtb.infrastructure.database.config import get_database_config


@click.group()
def integrity():
    """æ•°æ®å®Œæ•´æ€§æ£€æŸ¥å·¥å…·"""
    pass


@integrity.command()
@click.option('--format', type=click.Choice(['text', 'json']), default='text')
@click.option('--verbose', '-v', is_flag=True)
def check(format: str, verbose: bool):
    """æ£€æŸ¥æ•°æ®å®Œæ•´æ€§"""
    config = get_database_config()
    
    checker = IntegrityChecker(
        wtb_db_url=config.wtb_db_url,
        agentgit_db_path=str(config.agentgit_db_path),
    )
    
    report = checker.check()
    
    if format == 'json':
        click.echo(json.dumps(report.to_dict(), indent=2))
    else:
        click.echo(report.summary())
        
        if verbose and report.issues:
            click.echo("\nDetails:")
            for issue in report.issues:
                click.echo(f"  [{issue.severity.value.upper()}] {issue.message}")


@integrity.command()
@click.option('--dry-run', is_flag=True, help='åªæ˜¾ç¤ºä¼šæ‰§è¡Œçš„ä¿®å¤ï¼Œä¸å®é™…æ‰§è¡Œ')
@click.confirmation_option(prompt='ç¡®å®šè¦æ‰§è¡Œè‡ªåŠ¨ä¿®å¤å—ï¼Ÿ')
def repair(dry_run: bool):
    """æ£€æŸ¥å¹¶è‡ªåŠ¨ä¿®å¤å¯ä¿®å¤çš„é—®é¢˜"""
    config = get_database_config()
    
    checker = IntegrityChecker(
        wtb_db_url=config.wtb_db_url,
        agentgit_db_path=str(config.agentgit_db_path),
    )
    
    if dry_run:
        report = checker.check()
        auto_repairable = [i for i in report.issues if i.auto_repairable]
        click.echo(f"Would repair {len(auto_repairable)} issues:")
        for issue in auto_repairable:
            click.echo(f"  - {issue.suggested_action.value}: {issue.message}")
    else:
        report = checker.check_and_repair()
        click.echo(report.summary())


if __name__ == '__main__':
    integrity()
```

---

## 4. P1: å……è¡€é¢†åŸŸæ¨¡å‹è®¾è®¡

### 4.1 è®¾è®¡ç›®æ ‡

å°†ä¸šåŠ¡é€»è¾‘ä» `ExecutionController` è¿ç§»åˆ° `Execution` å®ä½“ä¸­ï¼Œä½¿é¢†åŸŸæ¨¡å‹æ›´åŠ ä¸°å¯Œã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è´«è¡€ vs å……è¡€æ¨¡å‹å¯¹æ¯”                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                  â”‚
â”‚  è´«è¡€æ¨¡å‹ (Anemic - å½“å‰):                                                       â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                      â”‚
â”‚                                                                                  â”‚
â”‚  ExecutionController                    Execution                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ + run()                     â”‚       â”‚ + id: str                   â”‚         â”‚
â”‚  â”‚   â””â”€ å¾ªç¯æ‰§è¡ŒèŠ‚ç‚¹            â”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚ + status: ExecutionStatus  â”‚         â”‚
â”‚  â”‚   â””â”€ æ›´æ–° state             â”‚       â”‚ + state: ExecutionState    â”‚         â”‚
â”‚  â”‚   â””â”€ åˆ¤æ–­æ–­ç‚¹               â”‚       â”‚                             â”‚         â”‚
â”‚  â”‚   â””â”€ åˆ›å»º checkpoint        â”‚       â”‚ + can_run(): bool          â”‚         â”‚
â”‚  â”‚                             â”‚       â”‚ + start()  # ä»…æ”¹çŠ¶æ€       â”‚         â”‚
â”‚  â”‚ ğŸ’¡ å¤§é‡ä¸šåŠ¡é€»è¾‘åœ¨ Service   â”‚       â”‚ + pause()  # ä»…æ”¹çŠ¶æ€       â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                                  â”‚
â”‚  å……è¡€æ¨¡å‹ (Rich - ç›®æ ‡):                                                         â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                      â”‚
â”‚                                                                                  â”‚
â”‚  ExecutionController                    Execution                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ + run()                     â”‚       â”‚ + id: str                   â”‚         â”‚
â”‚  â”‚   â””â”€ workflow = get(...)    â”‚       â”‚ + status: ExecutionStatus  â”‚         â”‚
â”‚  â”‚   â””â”€ execution.execute(wf)  â”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚ + state: ExecutionState    â”‚         â”‚
â”‚  â”‚   â””â”€ uow.commit()           â”‚       â”‚                             â”‚         â”‚
â”‚  â”‚                             â”‚       â”‚ + execute(workflow)         â”‚         â”‚
â”‚  â”‚ ğŸ’¡ åªè´Ÿè´£åè°ƒå’ŒæŒä¹…åŒ–        â”‚       â”‚   â””â”€ å¾ªç¯æ‰§è¡ŒèŠ‚ç‚¹           â”‚         â”‚
â”‚  â”‚                             â”‚       â”‚   â””â”€ æ›´æ–° state            â”‚         â”‚
â”‚  â”‚                             â”‚       â”‚   â””â”€ åˆ¤æ–­æ–­ç‚¹              â”‚         â”‚
â”‚  â”‚                             â”‚       â”‚                             â”‚         â”‚
â”‚  â”‚                             â”‚       â”‚ + advance_to_node(result)  â”‚         â”‚
â”‚  â”‚                             â”‚       â”‚ + is_at_breakpoint()       â”‚         â”‚
â”‚  â”‚                             â”‚       â”‚ + record_node_result()     â”‚         â”‚
â”‚  â”‚                             â”‚       â”‚                             â”‚         â”‚
â”‚  â”‚                             â”‚       â”‚ ğŸ’¡ ä¸šåŠ¡é€»è¾‘å°è£…åœ¨å®ä½“å†…      â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 Execution å®ä½“å¢å¼º

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# wtb/domain/models/workflow.py (å¢å¼ºç‰ˆ Execution)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class Execution:
    """
    Aggregate Root - å·¥ä½œæµæ‰§è¡Œå®ä¾‹ï¼ˆå……è¡€æ¨¡å‹ï¼‰ã€‚
    
    å°è£…æ‰§è¡Œçš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼š
    - çŠ¶æ€æœºè½¬æ¢
    - èŠ‚ç‚¹æ‰§è¡Œé€»è¾‘
    - æ–­ç‚¹æ£€æµ‹
    - çŠ¶æ€æ›´æ–°
    
    Design Philosophy:
    - ä¸šåŠ¡è§„åˆ™å°è£…åœ¨å®ä½“å†…
    - Service åªè´Ÿè´£åè°ƒå’ŒæŒä¹…åŒ–
    - å®ä½“è‡ªèº«ä¿è¯ä¸å˜é‡
    """
    
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    workflow_id: str = ""
    status: ExecutionStatus = ExecutionStatus.PENDING
    state: ExecutionState = field(default_factory=ExecutionState)
    
    # AgentGit integration
    agentgit_session_id: Optional[int] = None
    agentgit_checkpoint_id: Optional[int] = None
    
    # Timing
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    created_at: datetime = field(default_factory=datetime.now)
    
    # Error handling
    error_message: Optional[str] = None
    error_node_id: Optional[str] = None
    
    # Breakpoints
    breakpoints: List[str] = field(default_factory=list)
    
    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # State Machine (ä¿æŒåŸæœ‰)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def can_run(self) -> bool:
        return self.status in [ExecutionStatus.PENDING, ExecutionStatus.PAUSED]
    
    def can_pause(self) -> bool:
        return self.status == ExecutionStatus.RUNNING
    
    def can_resume(self) -> bool:
        return self.status == ExecutionStatus.PAUSED
    
    def can_rollback(self) -> bool:
        return self.status in [
            ExecutionStatus.PAUSED,
            ExecutionStatus.FAILED,
            ExecutionStatus.COMPLETED
        ]
    
    def start(self) -> None:
        """å¯åŠ¨æ‰§è¡Œ"""
        if not self.can_run():
            raise InvalidStateTransition(
                f"Cannot start execution in status {self.status.value}",
                current_status=self.status,
                attempted_action="start"
            )
        self.status = ExecutionStatus.RUNNING
        if self.started_at is None:
            self.started_at = datetime.now()
    
    def pause(self) -> None:
        """æš‚åœæ‰§è¡Œ"""
        if not self.can_pause():
            raise InvalidStateTransition(
                f"Cannot pause execution in status {self.status.value}",
                current_status=self.status,
                attempted_action="pause"
            )
        self.status = ExecutionStatus.PAUSED
    
    def resume(self) -> None:
        """æ¢å¤æ‰§è¡Œ"""
        if not self.can_resume():
            raise InvalidStateTransition(
                f"Cannot resume execution in status {self.status.value}",
                current_status=self.status,
                attempted_action="resume"
            )
        self.status = ExecutionStatus.RUNNING
    
    def complete(self) -> None:
        """å®Œæˆæ‰§è¡Œ"""
        self.status = ExecutionStatus.COMPLETED
        self.completed_at = datetime.now()
    
    def fail(self, error_message: str, node_id: Optional[str] = None) -> None:
        """æ ‡è®°å¤±è´¥"""
        self.status = ExecutionStatus.FAILED
        self.error_message = error_message
        self.error_node_id = node_id
        self.completed_at = datetime.now()
    
    def cancel(self) -> None:
        """å–æ¶ˆæ‰§è¡Œ"""
        self.status = ExecutionStatus.CANCELLED
        self.completed_at = datetime.now()
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Business Logic (æ–°å¢ - ä» ExecutionController è¿ç§»)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def is_at_breakpoint(self) -> bool:
        """æ£€æŸ¥å½“å‰æ˜¯å¦å¤„äºæ–­ç‚¹"""
        return self.state.current_node_id in self.breakpoints
    
    def has_more_nodes(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¿˜æœ‰èŠ‚ç‚¹è¦æ‰§è¡Œ"""
        return self.state.current_node_id is not None
    
    def record_node_result(
        self, 
        node_id: str, 
        result: Any, 
        success: bool = True
    ) -> None:
        """
        è®°å½•èŠ‚ç‚¹æ‰§è¡Œç»“æœã€‚
        
        ä¸šåŠ¡è§„åˆ™ï¼š
        - å°†èŠ‚ç‚¹æ·»åŠ åˆ°æ‰§è¡Œè·¯å¾„
        - ä¿å­˜èŠ‚ç‚¹ç»“æœ
        - å¦‚æœç»“æœæ˜¯å­—å…¸ï¼Œåˆå¹¶åˆ° workflow_variables
        """
        if not success:
            raise ValueError("Use fail() for failed node execution")
        
        self.state.execution_path.append(node_id)
        self.state.node_results[node_id] = result
        
        if isinstance(result, dict):
            self.state.workflow_variables.update(result)
    
    def advance_to_node(self, next_node_id: Optional[str]) -> None:
        """
        å‰è¿›åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚
        
        ä¸šåŠ¡è§„åˆ™ï¼š
        - æ›´æ–°å½“å‰èŠ‚ç‚¹
        - å¦‚æœ next_node_id ä¸º Noneï¼Œè¡¨ç¤ºå·¥ä½œæµç»“æŸ
        """
        self.state.current_node_id = next_node_id
        
        if next_node_id is None and self.status == ExecutionStatus.RUNNING:
            self.complete()
    
    def apply_state_modification(self, modifications: Dict[str, Any]) -> None:
        """
        åº”ç”¨çŠ¶æ€ä¿®æ”¹ï¼ˆç”¨äº resume æ—¶çš„çŠ¶æ€è°ƒæ•´ï¼‰ã€‚
        
        ä¸šåŠ¡è§„åˆ™ï¼š
        - åªèƒ½åœ¨ PAUSED çŠ¶æ€ä¸‹ä¿®æ”¹
        - åˆå¹¶åˆ° workflow_variables
        """
        if self.status != ExecutionStatus.PAUSED:
            raise InvalidStateTransition(
                "Can only modify state when paused",
                current_status=self.status,
                attempted_action="modify_state"
            )
        
        self.state.workflow_variables.update(modifications)
    
    def restore_from_checkpoint(self, state: ExecutionState) -> None:
        """
        ä»æ£€æŸ¥ç‚¹æ¢å¤çŠ¶æ€ï¼ˆç”¨äº rollbackï¼‰ã€‚
        
        ä¸šåŠ¡è§„åˆ™ï¼š
        - åªæœ‰å¯å›æ»šçŠ¶æ€æ‰èƒ½æ¢å¤
        - æ¢å¤åè¿›å…¥ PAUSED çŠ¶æ€
        """
        if not self.can_rollback():
            raise InvalidStateTransition(
                f"Cannot rollback execution in status {self.status.value}",
                current_status=self.status,
                attempted_action="rollback"
            )
        
        self.state = state
        self.status = ExecutionStatus.PAUSED
        self.error_message = None  # æ¸…é™¤é”™è¯¯
        self.error_node_id = None
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Query Methods
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def is_terminal(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¤„äºç»ˆæ€"""
        return self.status in [
            ExecutionStatus.COMPLETED,
            ExecutionStatus.FAILED,
            ExecutionStatus.CANCELLED
        ]
    
    def get_duration_seconds(self) -> Optional[float]:
        """è·å–æ‰§è¡Œæ—¶é•¿ï¼ˆç§’ï¼‰"""
        if not self.started_at:
            return None
        end_time = self.completed_at or datetime.now()
        return (end_time - self.started_at).total_seconds()
    
    def get_progress(self) -> Dict[str, Any]:
        """è·å–æ‰§è¡Œè¿›åº¦æ‘˜è¦"""
        return {
            "status": self.status.value,
            "current_node": self.state.current_node_id,
            "nodes_completed": len(self.state.execution_path),
            "execution_path": self.state.execution_path,
            "duration_seconds": self.get_duration_seconds(),
            "is_at_breakpoint": self.is_at_breakpoint(),
        }


# è‡ªå®šä¹‰å¼‚å¸¸
class InvalidStateTransition(Exception):
    """æ— æ•ˆçš„çŠ¶æ€è½¬æ¢"""
    
    def __init__(
        self, 
        message: str, 
        current_status: ExecutionStatus,
        attempted_action: str
    ):
        super().__init__(message)
        self.current_status = current_status
        self.attempted_action = attempted_action
```

### 4.3 ç²¾ç®€åçš„ ExecutionController

```python
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# wtb/application/services/execution_controller.py (ç²¾ç®€ç‰ˆ)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ExecutionController(IExecutionController):
    """
    æ‰§è¡Œæ§åˆ¶å™¨ï¼ˆç²¾ç®€ç‰ˆ - å……è¡€æ¨¡å‹ï¼‰ã€‚
    
    èŒè´£ï¼š
    - åè°ƒ Executionã€StateAdapterã€NodeExecutor
    - ç®¡ç†æŒä¹…åŒ–
    - ä¸åŒ…å«ä¸šåŠ¡é€»è¾‘ï¼ˆå·²ç§»åˆ° Execution å®ä½“ï¼‰
    """
    
    def __init__(
        self,
        execution_repository: IExecutionRepository,
        workflow_repository: IWorkflowRepository,
        state_adapter: IStateAdapter,
        node_executor: Optional[INodeExecutor] = None,
    ):
        self._exec_repo = execution_repository
        self._workflow_repo = workflow_repository
        self._state_adapter = state_adapter
        self._node_executor = node_executor or DefaultNodeExecutor()
    
    def run(self, execution_id: str) -> Execution:
        """å¯åŠ¨æˆ–ç»§ç»­æ‰§è¡Œ"""
        execution = self._get_execution(execution_id)
        workflow = self._get_workflow(execution.workflow_id)
        
        # çŠ¶æ€è½¬æ¢ï¼ˆä¸šåŠ¡è§„åˆ™åœ¨ Execution å†…ï¼‰
        if execution.status == ExecutionStatus.PENDING:
            execution.start()
        elif execution.status == ExecutionStatus.PAUSED:
            execution.resume()
        else:
            raise RuntimeError(f"Cannot run execution in status {execution.status.value}")
        
        # è®¾ç½® session
        if execution.agentgit_session_id:
            self._state_adapter.set_current_session(execution.agentgit_session_id)
        
        # ä¸»å¾ªç¯
        try:
            while execution.status == ExecutionStatus.RUNNING:
                # æ£€æŸ¥æ˜¯å¦è¿˜æœ‰èŠ‚ç‚¹
                if not execution.has_more_nodes():
                    break
                
                current_node_id = execution.state.current_node_id
                
                # æ–­ç‚¹æ£€æµ‹ï¼ˆä¸šåŠ¡è§„åˆ™åœ¨ Execution å†…ï¼‰
                if execution.is_at_breakpoint():
                    self._create_checkpoint(execution, current_node_id, "Breakpoint")
                    execution.pause()
                    break
                
                # è·å–èŠ‚ç‚¹
                node = workflow.get_node(current_node_id)
                if not node:
                    raise ValueError(f"Node {current_node_id} not found")
                
                # æ‰§è¡ŒèŠ‚ç‚¹
                result = self._execute_node(execution, workflow, node)
                
                if not result.success:
                    execution.fail(result.error or "Node failed", current_node_id)
                    break
        
        except Exception as e:
            execution.fail(str(e), execution.state.current_node_id)
        
        # æŒä¹…åŒ–
        self._exec_repo.update(execution)
        return execution
    
    def _execute_node(
        self, 
        execution: Execution, 
        workflow: TestWorkflow, 
        node: WorkflowNode
    ) -> NodeExecutionResult:
        """æ‰§è¡Œå•ä¸ªèŠ‚ç‚¹"""
        current_node_id = node.id
        
        # Entry checkpoint
        entry_cp_id = self._state_adapter.save_checkpoint_with_boundary(
            state=execution.state,
            node_id=current_node_id,
            trigger=CheckpointTrigger.AUTO,
            is_node_entry=True,
            name=f"Entry: {current_node_id}"
        )
        
        # æ‰§è¡Œ
        result = self._node_executor.execute(
            node=node,
            context=execution.state.workflow_variables,
        )
        
        if result.success:
            # è®°å½•ç»“æœï¼ˆä¸šåŠ¡è§„åˆ™åœ¨ Execution å†…ï¼‰
            execution.record_node_result(current_node_id, result.output)
            
            # Exit checkpoint
            self._state_adapter.save_checkpoint_with_boundary(
                state=execution.state,
                node_id=current_node_id,
                trigger=CheckpointTrigger.AUTO,
                is_node_exit=True,
                name=f"Exit: {current_node_id}"
            )
            
            # ç¡®å®šä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆä¸šåŠ¡è§„åˆ™åœ¨ Execution å†…ï¼‰
            next_node_id = self._determine_next_node(workflow, execution, result.output)
            execution.advance_to_node(next_node_id)
        
        return result
    
    def rollback(self, execution_id: str, checkpoint_id: int) -> Execution:
        """å›æ»šåˆ°æ£€æŸ¥ç‚¹"""
        execution = self._get_execution(execution_id)
        
        # é€šè¿‡ StateAdapter æ¢å¤çŠ¶æ€
        restored_state = self._state_adapter.rollback(checkpoint_id)
        
        # åº”ç”¨åˆ° Executionï¼ˆä¸šåŠ¡è§„åˆ™åœ¨ Execution å†…ï¼‰
        execution.restore_from_checkpoint(restored_state)
        execution.agentgit_checkpoint_id = checkpoint_id
        
        # æŒä¹…åŒ–
        self._exec_repo.update(execution)
        return execution
    
    # ... å…¶ä»–æ–¹æ³•ä¿æŒç®€æ´
```

---

## 5. å®æ–½è®¡åˆ’

### 5.1 Phase 1: P0 å®ç° (Week 1-2)

| ä»»åŠ¡ | æ–‡ä»¶ | ä¼°æ—¶ |
|------|------|------|
| Outbox è¡¨è¿ç§» | `migrations/002_add_outbox.sql` | 2h |
| Outbox é¢†åŸŸæ¨¡å‹ | `domain/models/outbox.py` | 2h |
| Outbox Repository | `domain/interfaces/outbox_repository.py` | 2h |
| SQLAlchemy å®ç° | `infrastructure/database/repositories/outbox_repository.py` | 4h |
| InMemory å®ç° | `infrastructure/database/inmemory/outbox_repository.py` | 2h |
| æ›´æ–° IUnitOfWork | `domain/interfaces/unit_of_work.py` | 1h |
| Outbox Processor | `infrastructure/outbox/processor.py` | 6h |
| ä¿®æ”¹ StateAdapter | `infrastructure/adapters/agentgit_state_adapter.py` | 4h |
| å•å…ƒæµ‹è¯• | `tests/test_wtb/test_outbox.py` | 4h |

### 5.2 Phase 2: P0 IntegrityChecker (Week 2)

| ä»»åŠ¡ | æ–‡ä»¶ | ä¼°æ—¶ |
|------|------|------|
| Integrity æ¨¡å‹ | `domain/models/integrity.py` | 2h |
| IntegrityChecker | `infrastructure/integrity/checker.py` | 6h |
| CLI å·¥å…· | `cli/integrity.py` | 2h |
| æ·»åŠ  list_all åˆ° Repos | å¤šä¸ªæ–‡ä»¶ | 2h |
| é›†æˆæµ‹è¯• | `tests/test_wtb/test_integrity.py` | 4h |

### 5.3 Phase 3: P1 å……è¡€æ¨¡å‹ (Week 3)

| ä»»åŠ¡ | æ–‡ä»¶ | ä¼°æ—¶ |
|------|------|------|
| å¢å¼º Execution | `domain/models/workflow.py` | 4h |
| è‡ªå®šä¹‰å¼‚å¸¸ | `domain/exceptions.py` | 1h |
| ç²¾ç®€ Controller | `application/services/execution_controller.py` | 4h |
| æ›´æ–°æµ‹è¯• | `tests/test_wtb/test_execution.py` | 4h |

---

## 6. æµ‹è¯•ç­–ç•¥

### 6.1 Outbox Pattern æµ‹è¯•

```python
# tests/test_wtb/test_outbox.py

class TestOutboxPattern:
    """Outbox Pattern é›†æˆæµ‹è¯•"""
    
    def test_checkpoint_with_outbox_event_atomicity(self, uow):
        """éªŒè¯ checkpoint å’Œ outbox äº‹ä»¶åŸå­å†™å…¥"""
        # Arrange
        adapter = AgentGitStateAdapter(...)
        
        # Act
        checkpoint_id = adapter.save_checkpoint_with_boundary(...)
        
        # Assert - ä¸¤è€…éƒ½å­˜åœ¨æˆ–éƒ½ä¸å­˜åœ¨
        with uow:
            event = uow.outbox.get_by_id(...)
            assert event is not None
            assert event.payload["checkpoint_id"] == checkpoint_id
    
    def test_outbox_processor_handles_failure(self, uow):
        """éªŒè¯ Processor å¤„ç†å¤±è´¥åæ­£ç¡®æ ‡è®°"""
        # Arrange
        processor = OutboxProcessor(...)
        
        # Act - åˆ›å»ºä¸€ä¸ªä¼šå¤±è´¥çš„äº‹ä»¶
        with uow:
            event = OutboxEvent(
                event_type=OutboxEventType.CHECKPOINT_VERIFY,
                payload={"checkpoint_id": 99999}  # ä¸å­˜åœ¨
            )
            uow.outbox.add(event)
            uow.commit()
        
        processor.process_once()
        
        # Assert
        with uow:
            event = uow.outbox.get_by_id(event.event_id)
            assert event.status == OutboxStatus.FAILED
            assert event.retry_count == 1
```

### 6.2 IntegrityChecker æµ‹è¯•

```python
# tests/test_wtb/test_integrity.py

class TestIntegrityChecker:
    """å®Œæ•´æ€§æ£€æŸ¥å™¨æµ‹è¯•"""
    
    def test_detect_dangling_reference(self, uow, agentgit_db):
        """æ£€æµ‹æ‚¬ç©ºå¼•ç”¨"""
        # Arrange - åˆ›å»ºä¸€ä¸ªå¼•ç”¨ä¸å­˜åœ¨ checkpoint çš„ boundary
        with uow:
            boundary = NodeBoundary(
                node_id="test",
                entry_checkpoint_id=99999,  # ä¸å­˜åœ¨
            )
            uow.node_boundaries.add(boundary)
            uow.commit()
        
        # Act
        checker = IntegrityChecker(...)
        report = checker.check()
        
        # Assert
        assert not report.is_healthy
        assert report.critical_count == 1
        assert report.issues[0].issue_type == IntegrityIssueType.DANGLING_REFERENCE
    
    def test_auto_repair_orphan(self, uow):
        """æµ‹è¯•è‡ªåŠ¨ä¿®å¤å­¤å„¿è®°å½•"""
        # Arrange
        ...
        
        # Act
        report = checker.check_and_repair()
        
        # Assert
        assert report.repaired_count == 1
```

---

## 7. å…³é”®è®¾è®¡å†³ç­–

| å†³ç­– | é€‰æ‹© | ç†ç”± |
|------|------|------|
| **äº‹åŠ¡ä¸­å¿ƒ** | WTB Database | æ‰€æœ‰ä¸šåŠ¡æ•°æ® + Outbox åŸå­å†™å…¥ |
| Outbox å­˜å‚¨ä½ç½® | WTB Database | ä¸ä¸šåŠ¡æ•°æ®åŒäº‹åŠ¡ï¼Œä¿è¯åŸå­æ€§ |
| Processor æ¨¡å¼ | åå°çº¿ç¨‹è½®è¯¢ | ç®€å•å¯é ï¼Œé€‚åˆå•ä½“åº”ç”¨ |
| å¹‚ç­‰é”® | event_id (UUID) | é˜²æ­¢é‡å¤å¤„ç† |
| é‡è¯•ç­–ç•¥ | æŒ‡æ•°é€€é¿ + æœ€å¤§æ¬¡æ•° | é¿å…æ— é™é‡è¯• |
| IntegrityChecker èŒƒå›´ | ä¸‰åº“å®Œæ•´æ£€æŸ¥ | WTB â†” AgentGit â†” FileTracker |
| IntegrityChecker è¿è¡Œæ—¶æœº | å®šæ—¶ä»»åŠ¡ + æ‰‹åŠ¨ | ä¸å½±å“æ­£å¸¸ä¸šåŠ¡ |
| å……è¡€æ¨¡å‹èŒƒå›´ | Execution å®ä½“ | æ ¸å¿ƒä¸šåŠ¡é€»è¾‘é›†ä¸­å¤„ |
| FileTracker é›†æˆ | å¯é€‰ | é…ç½® filetracker_connection å¯ç”¨ |

### ä¸‰åº“èŒè´£åˆ†å·¥

| æ•°æ®åº“ | æŠ€æœ¯æ ˆ | èŒè´£ | Outbox éªŒè¯é¡¹ |
|--------|--------|------|---------------|
| **WTB Database** | SQLite/PostgreSQL | äº‹åŠ¡ä¸­å¿ƒã€ä¸šåŠ¡æ•°æ®ã€Outbox | - |
| **AgentGit Database** | SQLite | çŠ¶æ€å¿«ç…§ã€ä¼šè¯ç®¡ç†ã€å›æ»š | checkpoint å­˜åœ¨æ€§ |
| **FileTracker Database** | PostgreSQL | æ–‡ä»¶å…ƒæ•°æ®ã€æäº¤å†å² | commit å­˜åœ¨æ€§ |
| **FileTracker Storage** | æ–‡ä»¶ç³»ç»Ÿ | å®é™…æ–‡ä»¶å†…å®¹ (Content-Addressable) | blob æ–‡ä»¶å­˜åœ¨æ€§ |

---

## 8. é™„å½•ï¼šæ–‡ä»¶ç»“æ„

```
wtb/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ workflow.py        # å¢å¼º Execution (å……è¡€æ¨¡å‹)
â”‚   â”‚   â”œâ”€â”€ outbox.py          # NEW: Outbox äº‹ä»¶æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ integrity.py       # NEW: å®Œæ•´æ€§æ£€æŸ¥æ¨¡å‹
â”‚   â”‚   â””â”€â”€ checkpoint_file.py # å·²æœ‰: Checkpoint-File é“¾æ¥
â”‚   â”œâ”€â”€ interfaces/
â”‚   â”‚   â”œâ”€â”€ unit_of_work.py    # æ›´æ–°: æ·»åŠ  outbox ä»“å‚¨
â”‚   â”‚   â”œâ”€â”€ outbox_repository.py # NEW: Outbox ä»“å‚¨æ¥å£
â”‚   â”‚   â””â”€â”€ state_adapter.py   # å·²æœ‰: çŠ¶æ€é€‚é…å™¨æ¥å£
â”‚   â””â”€â”€ exceptions.py          # NEW: é¢†åŸŸå¼‚å¸¸ (InvalidStateTransition ç­‰)
â”‚
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”œâ”€â”€ outbox_repository.py        # NEW: SQLAlchemy Outbox ä»“å‚¨
â”‚   â”‚   â”‚   â””â”€â”€ checkpoint_file_repository.py # å·²æœ‰: æ›´æ–°æ”¯æŒ list_all
â”‚   â”‚   â”œâ”€â”€ inmemory/
â”‚   â”‚   â”‚   â””â”€â”€ outbox_repository.py        # NEW: InMemory Outbox ä»“å‚¨
â”‚   â”‚   â””â”€â”€ migrations/
â”‚   â”‚       â””â”€â”€ 002_add_outbox.sql          # NEW: Outbox è¡¨
â”‚   â”‚
â”‚   â”œâ”€â”€ outbox/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ processor.py       # NEW: Outbox Processor (ä¸‰åº“éªŒè¯)
â”‚   â”‚   â””â”€â”€ handlers/
â”‚   â”‚       â”œâ”€â”€ agentgit_handler.py    # NEW: AgentGit éªŒè¯å¤„ç†å™¨
â”‚   â”‚       â””â”€â”€ filetracker_handler.py # NEW: FileTracker éªŒè¯å¤„ç†å™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ integrity/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ checker.py         # NEW: IntegrityChecker (ä¸‰åº“æ£€æŸ¥)
â”‚   â”‚   â””â”€â”€ reporters/
â”‚   â”‚       â”œâ”€â”€ console_reporter.py    # NEW: æ§åˆ¶å°æŠ¥å‘Š
â”‚   â”‚       â””â”€â”€ json_reporter.py       # NEW: JSON æŠ¥å‘Š
â”‚   â”‚
â”‚   â””â”€â”€ adapters/
â”‚       â”œâ”€â”€ agentgit_state_adapter.py  # æ›´æ–°: ä½¿ç”¨ Outbox Pattern
â”‚       â””â”€â”€ inmemory_state_adapter.py  # å·²æœ‰: æµ‹è¯•ç”¨
â”‚
â”œâ”€â”€ application/
â”‚   â””â”€â”€ services/
â”‚       â””â”€â”€ execution_controller.py  # ç²¾ç®€: ä¸šåŠ¡é€»è¾‘ç§»åˆ° Execution
â”‚
â””â”€â”€ cli/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ integrity.py           # NEW: integrity check/repair å‘½ä»¤
    â””â”€â”€ outbox.py              # NEW: outbox status/retry å‘½ä»¤
```

### ç›¸å…³å¤–éƒ¨æ¨¡å—

```
file_processing/file_processing/FileTracker/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ Commit.py                  # æäº¤æ¨¡å‹
â”œâ”€â”€ FileMemento.py             # æ–‡ä»¶å¿«ç…§æ¨¡å‹
â”œâ”€â”€ Repository/
â”‚   â”œâ”€â”€ BlobRepository.py      # Blob å­˜å‚¨ä»“å‚¨
â”‚   â”œâ”€â”€ CommitRepository.py    # æäº¤ä»“å‚¨
â”‚   â””â”€â”€ FileMementoRepository.py
â””â”€â”€ ORM/
    â”œâ”€â”€ BlobORM.py             # Blob æ•°æ®è®¿é—®
    â”œâ”€â”€ CommitORM.py           # æäº¤æ•°æ®è®¿é—®
    â””â”€â”€ FileMementoORM.py
```

---

## æ–‡æ¡£å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | å˜æ›´ |
|------|------|------|
| 1.0 | 2024-12-23 | åˆå§‹ç‰ˆæœ¬ |

